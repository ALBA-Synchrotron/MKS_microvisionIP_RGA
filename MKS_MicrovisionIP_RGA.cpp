/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
static const char * MKS_MicrovisionIP_RGA_TagName = "$Name:  $";
//=============================================================================
//
// file :        MKS_MicrovisionIP_RGA.cpp
//
// description : C++ source for the MKS_MicrovisionIP_RGA class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               MKS_MicrovisionIP_RGA are implemented in this file.
//
// project :     MKS Microvision IP RGA
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <tango.h>
#include <MKS_MicrovisionIP_RGA.h>
#include <MKS_MicrovisionIP_RGAClass.h>
#include <RGAThread.h>
#include <sys/time.h>
#include <math.h>

/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA.cpp

/**
 *  MKS_MicrovisionIP_RGA class description:
 *    This device server will control MKS Microvision IP Residual Gas Analyser.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name      |  Method name
//================================================================
//  State             |  dev_state
//  Status            |  dev_status
//  On                |  on
//  Off               |  off
//  Reset             |  reset
//  SendCmd           |  send_cmd
//  Release           |  release
//  StartDegas        |  start_degas
//  StopDegas         |  stop_degas
//  StoreStaticPress  |  store_static_press
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  MeasurementMode    |  Tango::DevString	Scalar
//  Accuracy           |  Tango::DevUShort	Scalar
//  FilamentNumber     |  Tango::DevUShort	Scalar
//  DetectorIndex      |  Tango::DevUShort	Scalar
//  DetectorVoltage    |  Tango::DevDouble	Scalar
//  StartMass          |  Tango::DevUShort	Scalar
//  EndMass            |  Tango::DevUShort	Scalar
//  LeakCheckMass      |  Tango::DevDouble	Scalar
//  Timeout            |  Tango::DevLong	Scalar
//  Gain               |  Tango::DevUShort	Scalar
//  SourceIndex        |  Tango::DevUShort	Scalar
//  FilterMode         |  Tango::DevString	Scalar
//  LeakCheckPressure  |  Tango::DevDouble	Scalar
//  DegasStatus        |  Tango::DevString	Scalar
//  FilamentDegas      |  Tango::DevBoolean	Scalar
//  LifetimePressure   |  Tango::DevDouble	Scalar
//  Masses             |  Tango::DevDouble	Spectrum  ( max = 101)
//  MassesHistory      |  Tango::DevDouble	Spectrum  ( max = 101)
//  StaticPressures    |  Tango::DevDouble	Spectrum  ( max = 101)
//================================================================

namespace MKS_MicrovisionIP_RGA_ns
{
/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGA::MKS_MicrovisionIP_RGA()
 *	Description : Constructors for a Tango device
 *                implementing the classMKS_MicrovisionIP_RGA
 */
//--------------------------------------------------------
MKS_MicrovisionIP_RGA::MKS_MicrovisionIP_RGA(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::constructor_1
}
//--------------------------------------------------------
MKS_MicrovisionIP_RGA::MKS_MicrovisionIP_RGA(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::constructor_2
}
//--------------------------------------------------------
MKS_MicrovisionIP_RGA::MKS_MicrovisionIP_RGA(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGA::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::delete_device()
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	cerr << "Entering delete_device()" << endl;
	if(properties_initialized == false)
{
cerr << "Leaving delete_device due to properties_initialized equal to false" << endl;
		return;
}
	//	Delete device's allocated object
	if(released == false)
	{
		try
		{
			Tango::DevString resp;
			resp = send_cmd("Release");
			CORBA::string_free(resp);
		}
		catch(Tango::DevFailed &e)
		{
			Tango::Except::print_exception(e);
		}
	}
	if(rga_thread != NULL)
	{
		// kill the thread
		{
			omni_mutex_lock l(mutex);
			killthread = true;
		}
		rga_thread->join(NULL);
	}
	delete Socketds;
	delete attr_Timeout_read;
	delete attr_Accuracy_read;
	delete attr_FilamentNumber_read;
	delete attr_DetectorIndex_read;
	delete attr_Gain_read;
	delete attr_DetectorVoltage_read;
	delete attr_StartMass_read;
	delete attr_EndMass_read;
	delete attr_LeakCheckMass_read;
	delete attr_LeakCheckPressure_read;
	delete []*attr_MeasurementMode_read;
	delete attr_MeasurementMode_read;
	delete []*attr_FilterMode_read;
	delete attr_FilterMode_read;
	delete attr_SourceIndex_read;
	for(int i=0; i<=MaxMass ; i++)
		delete attr_Mass_read[i];
	delete [] attr_Mass_read;
	delete command_mutex;
	delete command_cond;
	CORBA::string_free(*attr_DegasStatus_read);
	delete attr_DegasStatus_read;
	delete attr_FilamentDegas_read;

cerr << "Leaving delete_device" << endl;

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::delete_device
}

//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGA::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::init_device()
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	cerr << "Entering init_device()" << endl;
	INFO_STREAM << "MKS_MicrovisionIP_RGA::MKS_MicrovisionIP_RGA() create device " << device_name << endl;
	//--------------------------------------------
	try
	{


	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::init_device) ENABLED START -----*/
	
	//	Initialize device
		properties_initialized = true;
	}
	catch(...)
	{
		ERROR_STREAM << "An exception occured while getting the properties, Maybe there is a network problem ???" << endl;
		properties_initialized = false;
		gettimeofday(&last_measure_time,NULL);
		time_until_reinit = 60; // 1 minute
cerr << "Throwing exception 1 from init_device()" << endl;
		throw;
	}
	Socketds = NULL;
	rga_thread = NULL;
	attr_DegasStatus_read = new Tango::DevString;
	*attr_DegasStatus_read = strdup("Unknown");
	
	get_device_property();
	
	released = false;
	threadisconnected = false;
	controlled = false;
	addbarchartOK = false;
	barchartadded = false;
	addsinglepeakOK = false;
	singlepeakadded = false;
	detectorinfoOK = false;
	manual_reset_needed = false;
	MultiplierState = "Unknown";
	FilamentTripReason = "None";
	degas_status = "Not degassing";
	command_mutex = new omni_mutex();
	command_cond = new omni_condition(command_mutex);
	tg = NULL;
	attr_list = NULL;

	///////  initialise attributes variables
	attr_Timeout_read = new Tango::DevLong;
	*attr_Timeout_read = timeout;
	timeout_secs = timeout / 1000;
	timeout_nanosecs = timeout * 1000000 - timeout_secs * 1000000000;
	
	attr_MeasurementMode_read = new Tango::DevString;
	*attr_MeasurementMode_read = new char[15];
	strcpy(*attr_MeasurementMode_read,measurementMode.c_str());
	if(strcasecmp(*attr_MeasurementMode_read,"Barchart") == 0) mode = BARCHART;
	else if(strcasecmp(*attr_MeasurementMode_read,"LeakCheck") == 0) mode = LEAKCHECK;
	else if(strcasecmp(*attr_MeasurementMode_read,"Analog") == 0) mode = ANALOG;
	else mode = BARCHART;
	
	attr_FilterMode_read = new Tango::DevString;
	*attr_FilterMode_read = new char[15];
	if((strcasecmp(filterMode.c_str(),"peakcenter") != 0) && (strcasecmp(filterMode.c_str(),"peakmax") != 0) && (strcasecmp(filterMode.c_str(),"peakaverage") != 0))
	{
		ERROR_STREAM << "Bad value for filterMode property! Possible values are \"PeakCenter\", \"PeakMax\" and \"PeakAverage\"" << endl;
		INFO_STREAM << "FilterMode set to \"PeakCenter\"" << endl;
		filterMode = "PeakCenter";
	}
	strcpy(*attr_FilterMode_read,filterMode.c_str());
	attr_Accuracy_read = new Tango::DevUShort;
	*attr_Accuracy_read = accuracy;
	attr_FilamentNumber_read = new Tango::DevUShort;
	*attr_FilamentNumber_read = filamentNumber;
	attr_DetectorIndex_read = new Tango::DevUShort;
	*attr_DetectorIndex_read = detectorIndex;
	attr_DetectorVoltage_read = new Tango::DevDouble;
	*attr_DetectorVoltage_read = 0.0;
	attr_StartMass_read = new Tango::DevUShort;
	*attr_StartMass_read = startMass;
	attr_EndMass_read = new Tango::DevUShort;
	*attr_EndMass_read = endMass;
	attr_LeakCheckMass_read = new Tango::DevDouble;
	*attr_LeakCheckMass_read = leakCheckMass;
	attr_LeakCheckPressure_read = new Tango::DevDouble;
	*attr_LeakCheckPressure_read = min_detectable_pressure;
	attr_Gain_read = new Tango::DevUShort;
	*attr_Gain_read = gain;
	attr_FilamentDegas_read = new Tango::DevBoolean(false);
	attr_SourceIndex_read = new Tango::DevUShort;
	if(sourceIndex > 5)
	{
		ERROR_STREAM << "Bad value for SourceIndex property (" << sourceIndex << ")! Possible values are [0-5] => set to 0" << endl;
		sourceIndex = 0;
	}
	*attr_SourceIndex_read = sourceIndex;
	attr_Mass_read = new Tango::DevDouble * [MaxMass+1];
	for(int i=0; i<=MaxMass ; i++)
	{
		attr_Mass_read[i] = new Tango::DevDouble;
		*attr_Mass_read[i] = min_detectable_pressure;
	}
	gettimeofday(&last_measure_time,NULL);
	
	///////
	Tango::MultiAttribute		*attr_list;
	attr_list = get_device_attr();
	Tango::WAttribute	&attr_scanmode = attr_list->get_w_attr_by_name ("MeasurementMode");
	attr_scanmode.set_write_value(*attr_MeasurementMode_read);
	Tango::WAttribute	&attr_scanaccuracy = attr_list->get_w_attr_by_name ("Accuracy");
	attr_scanaccuracy.set_write_value(*attr_Accuracy_read);
	Tango::WAttribute	&attr_multindex = attr_list->get_w_attr_by_name ("DetectorIndex");
	attr_multindex.set_write_value(*attr_DetectorIndex_read);
	Tango::WAttribute	&attr_startmass = attr_list->get_w_attr_by_name ("StartMass");
	attr_startmass.set_write_value(*attr_StartMass_read);
	Tango::WAttribute	&attr_endmass = attr_list->get_w_attr_by_name ("EndMass");
	attr_endmass.set_write_value(*attr_EndMass_read);
	Tango::WAttribute	&attr_leakcheckmass = attr_list->get_w_attr_by_name ("LeakCheckMass");
	attr_leakcheckmass.set_write_value(*attr_LeakCheckMass_read);
	Tango::WAttribute	&attr_timeout = attr_list->get_w_attr_by_name ("Timeout");
	attr_timeout.set_write_value(*attr_Timeout_read);
	Tango::WAttribute	&attr_egainindex = attr_list->get_w_attr_by_name ("Gain");
	attr_egainindex.set_write_value(*attr_Gain_read);
	Tango::WAttribute	&attr_sourceindex = attr_list->get_w_attr_by_name ("SourceIndex");
	attr_sourceindex.set_write_value(*attr_SourceIndex_read);
	Tango::WAttribute	&attr_filtermode = attr_list->get_w_attr_by_name ("FilterMode");
	attr_filtermode.set_write_value(*attr_FilterMode_read);
	///////
	try
	{
		Socketds = new Tango::DeviceProxy(socket_device);
	}
	catch(Tango::DevFailed &e)
	{
		Socketds = NULL;
cerr << "Throwing exception 2 from init_device()" << endl;
		throw;
	}

	int retries = DB_RETRIES;
	Tango::Util *tg = Tango::Util::instance();
	Tango::Database *db = tg->get_database();
	int db_to = db->get_timeout_millis();

//
// Implement a retry schema in case the DB is overloaded (Massive DS startup)
// preventing the Socket device to retrieve its properties from DB
//

	while (retries > 0)
	{
		try
		{
			Socketds->command_inout("Init");
			retries = 0;
		}
		catch(Tango::DevFailed &e) 
		{ 
			Tango::Except::print_exception(e);
			if (e.errors.length() >= 2)
			{
				if (::strcmp(e.errors[1].reason,"API_DeviceTimedOut") == 0)
				{
					db->set_timeout_millis(DB_TIMEOUT);
					retries--;
				}
				else
					retries = 0;
			}
			else
				retries = 0;
		}
	}
	db->set_timeout_millis(db_to);

	set_state(Tango::UNKNOWN);
	{
		omni_mutex_lock l(mutex);
		killthread = false;
		scanstarted = false;
		SerialNumber = "";
		threadisconnected = false;
		sensorstate = "Unknown";
		FilamentStatus = "FilamentStatus: Unknown";
		RFTripped = false;
		linkdown = LINK_DOWN_OK;
		Masses.clear();
		Masses.push_back(sqrt(-1.2)); // Masses[0] = NaN
		for(int i=1;i<=MaxMass;i++)
		{
			Masses.push_back(min_detectable_pressure);
		}
		RGA_Answer = "";
	}
	rga_thread = new RGAThread(this, mutex);	
	
	/////////////////////////// SENSORS /////////////////////////////
	// Get the serial Number
	Tango::DevString resp;
	try
	{
		resp = send_cmd("Sensors");
	}
	catch(Tango::DevFailed &e)
	{
		ERROR_STREAM << "Sensors command failed" << endl;
cerr << "RETURNING 1 from init_device()" << endl;
		return;
	}
	istringstream sensorsresp(resp);	
	string strtmp = "";
	sensorsresp >> strtmp;sensorsresp >> strtmp; // Sensors OK
	sensorsresp >> strtmp;sensorsresp >> strtmp; sensorsresp >> strtmp;// State SerialNumber Name
	sensorsresp >> sensorstate;
	sensorsresp >> SerialNumber;
	CORBA::string_free(resp);
	if(strcasecmp(sensorstate.c_str(),"Ready") == 0)
	{
	///////////////////////// CONTROL ///////////////////////////////////
		istringstream TagStream(MKS_MicrovisionIP_RGA_TagName);
		string rev = "";
		TagStream >> rev;
		TagStream >> rev;
		char controlcmd[256];
		snprintf(controlcmd,256,"Control \"Tango Device Server\" \"%s\"",rev.c_str());
		DEBUG_STREAM << "controlcmd = " << controlcmd << endl;
		try
		{
			resp = send_cmd(controlcmd);
		}
		catch(Tango::DevFailed &e)
		{
			ERROR_STREAM << "Control command failed" << endl;
cerr << "RETURNING 2 from init_device()" << endl;
			return;
		}
		CORBA::string_free(resp);
		controlled = true;
	}
	
	// DetectorInfo command to get the DetectorVoltage for the current Detector Index ?
	try
	{
		resp = send_cmd("DetectorInfo 0");
		istringstream detectinfo(resp);
		char linetmp[256];	
		detectinfo.getline(linetmp,256,'\r'); // Detector OK
		detectinfo.getline(linetmp,256,'\r'); // SourceIndex 0
		detectinfo.getline(linetmp,256,'\r'); // Name DefaultFactor DefaultVoltage etc ...
		char FaradMultiplier[256];
		detectinfo.getline(FaradMultiplier,256,'\r');
		istringstream faraday(FaradMultiplier);
		faraday >> strtmp; // Faraday
		faraday >> strtmp; // DefaultFactor
		faraday >> strtmp; // DefaultVoltage
		faraday >> strtmp; // Factor1
		faraday >> DetectorVoltages[0];
		char mult1[256];
		detectinfo.getline(mult1,256,'\r');
		istringstream multi1(mult1);
		multi1 >> strtmp; // Mult1
		multi1 >> strtmp; // DefaultFactor
		multi1 >> strtmp; // DefaultVoltage
		multi1 >> strtmp; // Factor1
		multi1 >> DetectorVoltages[1];
		char mult2[256];
		detectinfo.getline(mult2,256,'\r');
		istringstream multi2(mult2);
		multi2 >> strtmp; // Mult2
		multi2 >> strtmp; // DefaultFactor
		multi2 >> strtmp; // DefaultVoltage
		multi2 >> strtmp; // Factor1
		multi2 >> DetectorVoltages[2];
		char mult3[256];
		detectinfo.getline(mult3,256,'\r');
		istringstream multi3(mult3);
		multi3 >> strtmp; // Mult3
		multi3 >> strtmp; // DefaultFactor
		multi3 >> strtmp; // DefaultVoltage
		multi3 >> strtmp; // Factor1
		multi3 >> DetectorVoltages[3];
		CORBA::string_free(resp);
		detectorinfoOK = true;
		*attr_DetectorVoltage_read = DetectorVoltages[*attr_DetectorIndex_read];
		Tango::WAttribute	&attr_multvoltage = attr_list->get_w_attr_by_name ("DetectorVoltage");
		attr_multvoltage.set_write_value(*attr_DetectorVoltage_read);	
	}
	catch(Tango::DevFailed &e)
	{
		ERROR_STREAM << "DetectorInfo command failed" << endl;
	}
	
	// RFInfo command to know if the state of the RF
	try
	{
		resp = send_cmd("RFInfo");
		istringstream rfinfo(resp);
		char linetmp[256];
		rfinfo.getline(linetmp,256,'\r'); // RFInfo OK
		rfinfo.getline(linetmp,256,'\r'); // RFTripEnabled Yes/No
		rfinfo.getline(linetmp,256,'\r');
		rfinfo >> strtmp; // RFTripped
		rfinfo >> strtmp; // Yes/No
		if(strcasecmp(strtmp.c_str(),"yes") == 0)
		{
			omni_mutex_lock l(mutex);
			RFTripped = true;
		}
		else
		{
			omni_mutex_lock l(mutex);
			RFTripped = false;
		}
		CORBA::string_free(resp);
	}
	catch(Tango::DevFailed &e)
	{
		ERROR_STREAM << "RFInfo command failed" << endl;
	}
	
	if(controlled)
	{
		// FILAMENTSELECT
		char filamentselectcmd [20];
		snprintf(filamentselectcmd,20*sizeof(char),"FilamentSelect %d",*attr_FilamentNumber_read);
		try
		{
			resp = send_cmd(filamentselectcmd);
			CORBA::string_free(resp);
		}
		catch(Tango::DevFailed &e)
		{
			ERROR_STREAM << "FilamentSelect command failed" << endl;
cerr << "RETURNING 3 from init_device()" << endl;
			return;
		}
		Tango::WAttribute	&attr_filamentnum = attr_list->get_w_attr_by_name ("FilamentNumber");
		attr_filamentnum.set_write_value(*attr_FilamentNumber_read);
		//FILAMENTINFO
		try
		{
			resp =send_cmd("FilamentInfo");
			istringstream filinfo(resp);
			filinfo >> strtmp; filinfo >> strtmp;// FilamentInfo OK
			filinfo >> strtmp; // SummaryState
			{
				omni_mutex_lock l(mutex);
				FilamentState = "Unknown";
				filinfo >> FilamentState;
			}
			filinfo >> strtmp; // ActiveFilament
			ActiveFilament = "";
			filinfo >> ActiveFilament;
			{
				omni_mutex_lock l(mutex);
				FilamentStatus = "FilamentStatus " + ActiveFilament + " " + FilamentState;
			}
			filinfo >> strtmp; filinfo >> strtmp; // ExternalTripEnable
			filinfo >> strtmp; filinfo >> strtmp; // ExternalTripMode
			filinfo >> strtmp; filinfo >> strtmp; // EmissionTripEnable
			filinfo >> strtmp; filinfo >> strtmp; // MaxOnTime
			filinfo >> strtmp; filinfo >> strtmp; // OnTimeRemaining
			filinfo >> strtmp; // Trip
			{
				omni_mutex_lock l(mutex);
				filinfo >> FilamentTripReason;
			}			
			CORBA::string_free(resp);
		}
		catch(Tango::DevFailed &e)
		{
			ERROR_STREAM << "FilamentInfo command failed" << endl;
		}
		
		
		///////// ADD MEASUREMENTS /////////
		//////////// Barchart //////////////////
		//  AddBarchart
		char addBarchartCmd[256];
		snprintf(addBarchartCmd,256,"AddBarchart bar %d %d %s %d %d %d %d",*attr_StartMass_read,*attr_EndMass_read,*attr_FilterMode_read,*attr_Accuracy_read,*attr_Gain_read,*attr_SourceIndex_read,*attr_DetectorIndex_read);
		try
		{
			resp = send_cmd(addBarchartCmd);
		}
		catch(Tango::DevFailed &e)
		{
			ERROR_STREAM << "AddBarchart command failed" << endl;
			if(strcmp(e.errors[0].reason,"CommandError") == 0)
			{
				istringstream errortype(e.errors[0].desc.in());
				char firstline[256];
				errortype.getline(firstline,256,'\r');
				errortype >> strtmp;
				int errornumber = 0;
				errortype >> errornumber;
				if(errornumber == 500)
					manual_reset_needed = true;
			}
cerr << "RETURNING 4 from init_device()" << endl;
			return;
		}
		CORBA::string_free(resp);
		addbarchartOK = true;
		if(strcasecmp(*attr_MeasurementMode_read,"Barchart") == 0)
		{
			// scanadd bar
			try
			{
				resp = send_cmd("ScanAdd bar");
			}
			catch(Tango::DevFailed &e)
			{
				ERROR_STREAM << "\"ScanAdd bar\" command failed" << endl;
cerr << "RETURNING 5 from init_device()" << endl;
				return;
			}
			CORBA::string_free(resp);
			barchartadded = true;
		}
		/////////// SinglePeak ////////////////
		//  AddSinglePeak
		char addSinglePeakCmd[256];
		snprintf(addSinglePeakCmd,256,"AddSinglePeak sp %g %d %d %d %d",*attr_LeakCheckMass_read,*attr_Accuracy_read,*attr_Gain_read,*attr_SourceIndex_read,*attr_DetectorIndex_read);
		try
		{
			resp = send_cmd(addSinglePeakCmd);
		}
		catch(Tango::DevFailed &e)
		{
			ERROR_STREAM << "AddSinglePeak command failed" << endl;
			if(strcmp(e.errors[0].reason,"CommandError") == 0)
			{
				istringstream errortype(e.errors[0].desc.in());
				char firstline[256];
				errortype.getline(firstline,256,'\r');
				errortype >> strtmp;
				int errornumber = 0;
				errortype >> errornumber;
				if(errornumber == 500)
					manual_reset_needed = true;
			}
cerr << "RETURNING 6 from init_device()" << endl;
			return;
		}
		CORBA::string_free(resp);
		addsinglepeakOK = true;
		if(strcasecmp(*attr_MeasurementMode_read,"Leakcheck") == 0)
		{
			// scanadd singlepeak
			string scanaddspcmd = "ScanAdd sp";
			try
			{
				resp = send_cmd("ScanAdd sp");
			}
			catch(Tango::DevFailed &e)
			{
				ERROR_STREAM << "\"ScanAdd sp\" command failed" << endl;
cerr << "RETURNING 7 from init_device()" << endl;
				return;
			}
			CORBA::string_free(resp);
			singlepeakadded = true;
		}
		/////////// SCANSTART ///////////////
		try
		{
			resp = send_cmd("ScanStart 16000");
			CORBA::string_free(resp);
		}
		catch(Tango::DevFailed &e)
		{
			ERROR_STREAM << "ScanStart failed" << endl;
cerr << "RETURNING 8 from init_device()" << endl;
			return;
		}
		{
			omni_mutex_lock l(mutex);
			scanstarted = true;	
		}
	} // controlled
	
cerr << "Leaving init_device()" << endl;

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::init_device
}

//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGA::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::get_device_property()
{
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Socket_device"));
	dev_prop.push_back(Tango::DbDatum("Timeout"));
	dev_prop.push_back(Tango::DbDatum("Accuracy"));
	dev_prop.push_back(Tango::DbDatum("FilamentNumber"));
	dev_prop.push_back(Tango::DbDatum("DetectorIndex"));
	dev_prop.push_back(Tango::DbDatum("StartMass"));
	dev_prop.push_back(Tango::DbDatum("EndMass"));
	dev_prop.push_back(Tango::DbDatum("LeakCheckMass"));
	dev_prop.push_back(Tango::DbDatum("Gain"));
	dev_prop.push_back(Tango::DbDatum("MeasurementMode"));
	dev_prop.push_back(Tango::DbDatum("Time_until_reinit"));
	dev_prop.push_back(Tango::DbDatum("SourceIndex"));
	dev_prop.push_back(Tango::DbDatum("FilterMode"));
	dev_prop.push_back(Tango::DbDatum("Min_detectable_pressure"));
	dev_prop.push_back(Tango::DbDatum("Degas_start_power"));
	dev_prop.push_back(Tango::DbDatum("Degas_end_power"));
	dev_prop.push_back(Tango::DbDatum("Degas_ramp_period"));
	dev_prop.push_back(Tango::DbDatum("Degas_max_power_period"));
	dev_prop.push_back(Tango::DbDatum("Degas_resettle_period"));
	dev_prop.push_back(Tango::DbDatum("StaticPressures"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on MKS_MicrovisionIP_RGAClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		MKS_MicrovisionIP_RGAClass	*ds_class =
			(static_cast<MKS_MicrovisionIP_RGAClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize Socket_device from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  socket_device;
		else {
			//	Try to initialize Socket_device from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  socket_device;
		}
		//	And try to extract Socket_device value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  socket_device;

		//	Try to initialize Timeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  timeout;
		else {
			//	Try to initialize Timeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  timeout;
		}
		//	And try to extract Timeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  timeout;

		//	Try to initialize Accuracy from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  accuracy;
		else {
			//	Try to initialize Accuracy from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  accuracy;
		}
		//	And try to extract Accuracy value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  accuracy;

		//	Try to initialize FilamentNumber from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  filamentNumber;
		else {
			//	Try to initialize FilamentNumber from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  filamentNumber;
		}
		//	And try to extract FilamentNumber value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  filamentNumber;

		//	Try to initialize DetectorIndex from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  detectorIndex;
		else {
			//	Try to initialize DetectorIndex from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  detectorIndex;
		}
		//	And try to extract DetectorIndex value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  detectorIndex;

		//	Try to initialize StartMass from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  startMass;
		else {
			//	Try to initialize StartMass from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  startMass;
		}
		//	And try to extract StartMass value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  startMass;

		//	Try to initialize EndMass from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  endMass;
		else {
			//	Try to initialize EndMass from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  endMass;
		}
		//	And try to extract EndMass value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  endMass;

		//	Try to initialize LeakCheckMass from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  leakCheckMass;
		else {
			//	Try to initialize LeakCheckMass from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  leakCheckMass;
		}
		//	And try to extract LeakCheckMass value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  leakCheckMass;

		//	Try to initialize Gain from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  gain;
		else {
			//	Try to initialize Gain from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  gain;
		}
		//	And try to extract Gain value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  gain;

		//	Try to initialize MeasurementMode from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  measurementMode;
		else {
			//	Try to initialize MeasurementMode from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  measurementMode;
		}
		//	And try to extract MeasurementMode value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  measurementMode;

		//	Try to initialize Time_until_reinit from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  time_until_reinit;
		else {
			//	Try to initialize Time_until_reinit from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  time_until_reinit;
		}
		//	And try to extract Time_until_reinit value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  time_until_reinit;

		//	Try to initialize SourceIndex from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  sourceIndex;
		else {
			//	Try to initialize SourceIndex from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  sourceIndex;
		}
		//	And try to extract SourceIndex value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sourceIndex;

		//	Try to initialize FilterMode from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  filterMode;
		else {
			//	Try to initialize FilterMode from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  filterMode;
		}
		//	And try to extract FilterMode value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  filterMode;

		//	Try to initialize Min_detectable_pressure from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  min_detectable_pressure;
		else {
			//	Try to initialize Min_detectable_pressure from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  min_detectable_pressure;
		}
		//	And try to extract Min_detectable_pressure value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  min_detectable_pressure;

		//	Try to initialize Degas_start_power from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  degas_start_power;
		else {
			//	Try to initialize Degas_start_power from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  degas_start_power;
		}
		//	And try to extract Degas_start_power value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  degas_start_power;

		//	Try to initialize Degas_end_power from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  degas_end_power;
		else {
			//	Try to initialize Degas_end_power from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  degas_end_power;
		}
		//	And try to extract Degas_end_power value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  degas_end_power;

		//	Try to initialize Degas_ramp_period from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  degas_ramp_period;
		else {
			//	Try to initialize Degas_ramp_period from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  degas_ramp_period;
		}
		//	And try to extract Degas_ramp_period value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  degas_ramp_period;

		//	Try to initialize Degas_max_power_period from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  degas_max_power_period;
		else {
			//	Try to initialize Degas_max_power_period from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  degas_max_power_period;
		}
		//	And try to extract Degas_max_power_period value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  degas_max_power_period;

		//	Try to initialize Degas_resettle_period from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  degas_resettle_period;
		else {
			//	Try to initialize Degas_resettle_period from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  degas_resettle_period;
		}
		//	And try to extract Degas_resettle_period value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  degas_resettle_period;

		//	Try to initialize StaticPressures from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  staticPressures;
		else {
			//	Try to initialize StaticPressures from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  staticPressures;
		}
		//	And try to extract StaticPressures value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  staticPressures;

	}

	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	INFO_STREAM << "Socket_device     = " << socket_device 		<< endl;
	INFO_STREAM << "Timeout           = " << timeout 		<< endl;
	INFO_STREAM << "Accuracy          = " << accuracy 		<< endl;;
	INFO_STREAM << "FilamentNumber    = " << filamentNumber		<< endl;
	INFO_STREAM << "DetectorIndex     = " << detectorIndex		<< endl;
	INFO_STREAM << "StartMass         = " << startMass		<< endl;
	INFO_STREAM << "EndMass           = " << endMass		<< endl;
	INFO_STREAM << "LeakCheckMass     = " << leakCheckMass		<< endl;
	INFO_STREAM << "Gain              = " << gain			<< endl;
	INFO_STREAM << "MeasurementMode   = " << measurementMode	<< endl;
	INFO_STREAM << "Time_until_reinit = " << time_until_reinit	<< endl;
	INFO_STREAM << "SourceIndex       = " << sourceIndex		<< endl;
	INFO_STREAM << "FilterMode        = " << filterMode		<< endl;
	INFO_STREAM << "MinDetectablePressure = " << min_detectable_pressure << endl;
	INFO_STREAM << "Degas_start_power = " << degas_start_power	<< endl;
	INFO_STREAM << "Degas_end_power   = " << degas_end_power	<< endl;
	INFO_STREAM << "Degas_ramp_period = " << degas_ramp_period	<< endl;
	INFO_STREAM << "Degas_max_power_period = " << degas_max_power_period << endl;
	INFO_STREAM << "Degas_resettle_period = " << degas_resettle_period << endl;

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGA::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::always_executed_hook()
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGA::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_attr_hardware) ENABLED START -----*/
	

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGA::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute MeasurementMode related method
 *	Description: Possible values :\n- Barchart\n- LeakCheck\n- Analog
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_MeasurementMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_MeasurementMode(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_MeasurementMode) ENABLED START -----*/
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	attr.set_value(attr_MeasurementMode_read);

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_MeasurementMode
}
//--------------------------------------------------------
/**
 *	Write attribute MeasurementMode related method
 *	Description: Possible values :\n- Barchart\n- LeakCheck\n- Analog
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::write_MeasurementMode(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::write_MeasurementMode(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::write_MeasurementMode) ENABLED START -----*/
	if(properties_initialized == false)
	{
		Tango::Except::throw_exception(
		(const char *) "DeviceNotInitialized",
		(const char *) "Device not correctly initialized.",
		(const char *) "MKS_MicrovisionIP_RGA::write_MeasurementMode()");
	}
	if(strcasecmp(w_val,"Barchart") == 0)
	{
		if(strcasecmp(*attr_MeasurementMode_read,"Barchart") == 0)
		{
			// we already are in Barchart Mode
			return;
		}
		else
		{
			// we weren't in Barchart Mode
			if(strcasecmp(*attr_MeasurementMode_read,"LeakCheck") == 0)
			{
				// we were in leakcheck mode
				if(attr_list == NULL)
					attr_list = get_device_attr();
				Tango::Attribute &att_LeakCheckPressure = attr_list->get_attr_by_name ("LeakCheckPressure");
				try
				{
					// set the LeakCheckPressure quality to ATTR_INVALID and fire an event
					att_LeakCheckPressure.set_quality(Tango::ATTR_INVALID);
					att_LeakCheckPressure.fire_change_event ();
				}
				catch (Tango::DevFailed &e)
				{
					Tango::Except::print_exception(e);
					att_LeakCheckPressure.fire_change_event (&e);
				}
			}
			
			// scanstop
			try
			{
				Tango::DevString resp  = send_cmd("ScanStop");
				CORBA::string_free(resp);
			}
			catch(Tango::DevFailed &e) 
			{ 
				ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_MeasurementMode: ScanStop command failed" << endl;
				throw; 
			}
			// scanadd bar
			try
			{
				Tango::DevString resp  = send_cmd("ScanAdd bar");
				CORBA::string_free(resp);
			}
			catch(Tango::DevFailed &e)
			{ 
				ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_MeasurementMode: ScanAdd command failed" << endl;
				throw; 
			}
			// scanstart
			try
			{
				Tango::DevString resp  = send_cmd("ScanStart 16000");
				CORBA::string_free(resp);
			}
			catch(Tango::DevFailed &e)
			{ 
				ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_MeasurementMode: ScanStart command failed" << endl;
				{
					omni_mutex_lock l(mutex);
					scanstarted = false;
				}
				throw; 
			}
			{
				omni_mutex_lock l(mutex);
				scanstarted = true;
				mode = BARCHART;
			}
			strcpy(*attr_MeasurementMode_read,"Barchart");
		}
	}
	else
	{ 
		if(strcasecmp(w_val,"Leakcheck") == 0)
		{	
			if(strcasecmp(*attr_MeasurementMode_read,"LeakCheck") == 0)
			{
				// we already are in LeakCheck Mode
				return;
			}
			else
			{
				// we weren't in LeakCheck Mode
				// scanstop
				try
				{
					Tango::DevString resp  = send_cmd("ScanStop");
					CORBA::string_free(resp);
				}
				catch(Tango::DevFailed &e) 
				{ 
					ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_MeasurementMode: ScanStop command failed" << endl;
					throw; 
				}
				// scanadd sp
				try
				{
					Tango::DevString resp  = send_cmd("ScanAdd sp");
					CORBA::string_free(resp);
				}
				catch(Tango::DevFailed &e)
				{ 
					ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_MeasurementMode: ScanAdd command failed" << endl;
					throw; 
				}
				struct timeval when;
				gettimeofday(&when,NULL);
				Tango::DevDouble value = min_detectable_pressure;
				for(int i =1; i<=MaxMass; i++)
				{
					Tango::AttrHistoryStack<Tango::DevDouble> chs;
					chs.length(1);
					TangoSys_OMemStream o;
					o << "Mass" << i;
					string attr_name = o.str();
					if(tg == NULL)
						tg = Tango::Util::instance(false);
					try
					{
						Tango::TimedAttrData<Tango::DevDouble> tcd(&value,when);
						chs.push(tcd);
						tg->fill_attr_polling_buffer(this,attr_name,chs);
					}
					catch(Tango::DevFailed &e)
					{
						Tango::Except::print_exception(e);
					}
					if(attr_list == NULL)
						attr_list = get_device_attr();
					Tango::Attribute &att_mass = attr_list->get_attr_by_name (attr_name.c_str());
					try
					{		 
						// set the new values and fire the change event 
						omni_mutex_lock l(mutex);
						*(attr_Mass_read[(unsigned int)i]) = Masses[(unsigned int)i] = value;
			 			att_mass.set_value(attr_Mass_read[(unsigned int)i]);
						att_mass.fire_change_event ();
					}
					catch (Tango::DevFailed &e)
					{
						Tango::Except::print_exception(e);
						att_mass.fire_change_event (&e);
					}
					try
					{		 
						// set the new values and fire the archive event 
						omni_mutex_lock l(mutex);
						*(attr_Mass_read[(unsigned int)i]) = value;
						att_mass.set_value(attr_Mass_read[(unsigned int)i]);
			 			att_mass.fire_archive_event ();
					}
					catch (Tango::DevFailed &e)
					{
						Tango::Except::print_exception(e);
//						att_mass.fire_archive_event (&e);
					}
				}
				// scanstart
				try
				{
					Tango::DevString resp  = send_cmd("ScanStart 16000");
					CORBA::string_free(resp);
				}
				catch(Tango::DevFailed &e)
				{ 
					ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_MeasurementMode: ScanStart command failed" << endl;
					{
						omni_mutex_lock l(mutex);
						scanstarted = false;
					}
					throw; 
				}
				{
					omni_mutex_lock l(mutex);
					scanstarted = true;
					mode = LEAKCHECK;
				}
				strcpy(*attr_MeasurementMode_read,"LeakCheck");
			}
		}
		else
		{
			Tango::Except::throw_exception
			((const char *) "BadInputParameter",
			(const char *) "Possible values are : \"Barchart\" and \"Leakcheck\"",
			(const char *) "MKS_MicrovisionIP_RGA::write_MeasurementMode");
		}
	}
	Tango::DbData		data;
	data.clear();
	data.push_back(Tango::DbDatum("measurementMode"));
	try
	{
		data[0] << w_val;
		get_db_device()->put_property(data);
	}
	catch(...)
	{
		ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_MeasurementMode: Error writing property in database" << endl;
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::write_MeasurementMode
}
//--------------------------------------------------------
/**
 *	Read attribute Accuracy related method
 *	Description: Measurement accuracy\npossible values : 0 to 8 (best accuracy, minimum speed).
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_Accuracy(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_Accuracy(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_Accuracy) ENABLED START -----*/
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	attr.set_value(attr_Accuracy_read);

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_Accuracy
}
//--------------------------------------------------------
/**
 *	Write attribute Accuracy related method
 *	Description: Measurement accuracy\npossible values : 0 to 8 (best accuracy, minimum speed).
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::write_Accuracy(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::write_Accuracy(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevUShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::write_Accuracy) ENABLED START -----*/
	if(properties_initialized == false)
	{
		Tango::Except::throw_exception(
		(const char *) "DeviceNotInitialized",
		(const char *) "Device not correctly initialized.",
		(const char *) "MKS_MicrovisionIP_RGA::write_Accuracy()");
	}	
	string measurementselectcmd = "MeasurementSelect bar";
	Tango::DevString resp;
	resp = send_cmd(measurementselectcmd.c_str());
	CORBA::string_free(resp);

	char changespeedcommand[30];
	snprintf(changespeedcommand,30*sizeof(char),"MeasurementAccuracy %d",w_val);
	resp = send_cmd(changespeedcommand);
	CORBA::string_free(resp);
	
	measurementselectcmd = "MeasurementSelect sp";
	resp = send_cmd(measurementselectcmd.c_str());
	CORBA::string_free(resp);
	resp = send_cmd(changespeedcommand);
	CORBA::string_free(resp);
	
	*attr_Accuracy_read = w_val;
	
	Tango::DbData		data;
	data.clear();
	data.push_back(Tango::DbDatum("accuracy"));
	try
	{
		data[0] << w_val;
		get_db_device()->put_property(data);
	}
	catch(...)
	{
		ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_Accuracy: Error writing property in database" << endl;
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::write_Accuracy
}
//--------------------------------------------------------
/**
 *	Read attribute FilamentNumber related method
 *	Description: Number of the active filament.
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_FilamentNumber(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_FilamentNumber(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_FilamentNumber) ENABLED START -----*/
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	attr.set_value(attr_FilamentNumber_read);

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_FilamentNumber
}
//--------------------------------------------------------
/**
 *	Write attribute FilamentNumber related method
 *	Description: Number of the active filament.
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::write_FilamentNumber(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::write_FilamentNumber(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevUShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::write_FilamentNumber) ENABLED START -----*/
	if(properties_initialized == false)
	{
		Tango::Except::throw_exception(
		(const char *) "DeviceNotInitialized",
		(const char *) "Device not correctly initialized.",
		(const char *) "MKS_MicrovisionIP_RGA::write_FilamentNumber()");
	}	char filamentselectcmd [20];
	snprintf(filamentselectcmd,20*sizeof(char),"FilamentSelect %d",w_val);
	Tango::DevString resp;
	resp = send_cmd(filamentselectcmd);
	CORBA::string_free(resp);
	*attr_FilamentNumber_read = w_val;
	
	Tango::DbData		data;
	data.clear();
	data.push_back(Tango::DbDatum("filamentNumber"));
	try
	{
		data[0] << w_val;
		get_db_device()->put_property(data);
	}
	catch(...)
	{
		ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_FilamentNumber: Error writing property in database" << endl;
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::write_FilamentNumber
}
//--------------------------------------------------------
/**
 *	Read attribute DetectorIndex related method
 *	Description: Detector (Multiplier) Index.\npossible values : from 0 to 3.\nChanges the selected measurements detector index. Faraday is detector 0 and if the sensor has a multiplier then\nindexes 1,2 and 3 provide alternate settings for the multiplier voltage.
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_DetectorIndex(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_DetectorIndex(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_DetectorIndex) ENABLED START -----*/
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	attr.set_value(attr_DetectorIndex_read);

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_DetectorIndex
}
//--------------------------------------------------------
/**
 *	Write attribute DetectorIndex related method
 *	Description: Detector (Multiplier) Index.\npossible values : from 0 to 3.\nChanges the selected measurements detector index. Faraday is detector 0 and if the sensor has a multiplier then\nindexes 1,2 and 3 provide alternate settings for the multiplier voltage.
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::write_DetectorIndex(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::write_DetectorIndex(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevUShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::write_DetectorIndex) ENABLED START -----*/
	if(properties_initialized == false)
	{
		Tango::Except::throw_exception(
		(const char *) "DeviceNotInitialized",
		(const char *) "Device not correctly initialized.",
		(const char *) "MKS_MicrovisionIP_RGA::write_DetectorIndex()");
	}	
	string measurementselectcmd = "MeasurementSelect bar";
	Tango::DevString resp;
	resp = send_cmd(measurementselectcmd.c_str());
	CORBA::string_free(resp);
	char changedetectorindexcmd[30];
	snprintf(changedetectorindexcmd,30*sizeof(char),"MeasurementDetectorIndex %d",w_val);
	resp = send_cmd(changedetectorindexcmd);
	CORBA::string_free(resp);
	
	measurementselectcmd = "MeasurementSelect sp";
	resp = send_cmd(measurementselectcmd.c_str());
	CORBA::string_free(resp);
	resp = send_cmd(changedetectorindexcmd);
	CORBA::string_free(resp);
	
	*attr_DetectorIndex_read = w_val;
	
	// read the DetectorVoltageDetectorVoltage associated with this new DetectorIndex
	// and change the setpoint of DetectorVoltage Attribute
	Tango::MultiAttribute		*attr_list;
	attr_list = get_device_attr();
	*attr_DetectorVoltage_read = DetectorVoltages[*attr_DetectorIndex_read];
	Tango::WAttribute	&attr_multvoltage = attr_list->get_w_attr_by_name ("DetectorVoltage");
	attr_multvoltage.set_write_value(*attr_DetectorVoltage_read);
		
	//Scanrestart
	try
	{
		resp = send_cmd("ScanRestart");
		CORBA::string_free(resp);
	}
	catch(Tango::DevFailed &e) { Tango::Except::print_exception(e); }
	
	Tango::DbData		data;
	data.clear();
	data.push_back(Tango::DbDatum("detectorIndex"));
	try
	{
		data[0] << w_val;
		get_db_device()->put_property(data);
	}
	catch(...)
	{
		ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_DetectorIndex: Error writing property in database" << endl;
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::write_DetectorIndex
}
//--------------------------------------------------------
/**
 *	Read attribute DetectorVoltage related method
 *	Description: Detector Voltage.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_DetectorVoltage(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_DetectorVoltage(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_DetectorVoltage) ENABLED START -----*/
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	if(controlled)
	{
		if(!detectorinfoOK)
		{
			// DetectorInfo command to get the DetectorVoltage for the current Detector Index ?
			try
			{
				Tango::DevString resp = send_cmd("DetectorInfo 0");
				istringstream detectinfo(resp);
				char linetmp[256];	
				detectinfo.getline(linetmp,256,'\r'); // Detector OK
				detectinfo.getline(linetmp,256,'\r'); // SourceIndex 0
				detectinfo.getline(linetmp,256,'\r'); // Name DefaultFactor DefaultVoltage etc ...
				char FaradMultiplier[256];
				detectinfo.getline(FaradMultiplier,256,'\r');
				istringstream faraday(FaradMultiplier);
				string strtmp = "";
				faraday >> strtmp; // Faraday
				faraday >> strtmp; // DefaultFactor
				faraday >> strtmp; // DefaultVoltage
				faraday >> strtmp; // Factor1
				faraday >> DetectorVoltages[0];
				char mult1[256];
				detectinfo.getline(mult1,256,'\r');
				istringstream multi1(mult1);
				multi1 >> strtmp; // Mult1
				multi1 >> strtmp; // DefaultFactor
				multi1 >> strtmp; // DefaultVoltage
				multi1 >> strtmp; // Factor1
				multi1 >> DetectorVoltages[1];
				char mult2[256];
				detectinfo.getline(mult2,256,'\r');
				istringstream multi2(mult2);
				multi2 >> strtmp; // Mult2
				multi2 >> strtmp; // DefaultFactor
				multi2 >> strtmp; // DefaultVoltage
				multi2 >> strtmp; // Factor1
				multi2 >> DetectorVoltages[2];
				char mult3[256];
				detectinfo.getline(mult3,256,'\r');
				istringstream multi3(mult3);
				multi3 >> strtmp; // Mult3
				multi3 >> strtmp; // DefaultFactor
				multi3 >> strtmp; // DefaultVoltage
				multi3 >> strtmp; // Factor1
				multi3 >> DetectorVoltages[3];
				CORBA::string_free(resp);
				detectorinfoOK = true;
			}
			catch(Tango::DevFailed &e)
			{
				ERROR_STREAM << "DetectorInfo command failed" << endl;
				throw;
			}
		}
		*attr_DetectorVoltage_read = DetectorVoltages[*attr_DetectorIndex_read];
		attr.set_value(attr_DetectorVoltage_read);
	}
	else
	{
		Tango::Except::throw_exception(
		(const char *) "SensorNotControlled",
		(const char *) "Could not get Detector Voltage, the sensor is not controlled by the Tango device server",
		(const char *) "MKS_MicrovisionIP_RGA::read_DetectorVoltage()");
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_DetectorVoltage
}
//--------------------------------------------------------
/**
 *	Write attribute DetectorVoltage related method
 *	Description: Detector Voltage.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::write_DetectorVoltage(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::write_DetectorVoltage(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::write_DetectorVoltage) ENABLED START -----*/
	if(properties_initialized == false)
	{
		Tango::Except::throw_exception(
		(const char *) "DeviceNotInitialized",
		(const char *) "Device not correctly initialized.",
		(const char *) "MKS_MicrovisionIP_RGA::write_DetectorVoltage()");
	}	char detectorvoltagecmd [40];
	//snprintf(detectorvoltagecmd,40*sizeof(char),"DetectorVoltage 0 %d %d %f",*attr_DetectorIndex_read,*attr_FilamentNumber_read,w_val);
	snprintf(detectorvoltagecmd,40*sizeof(char),"DetectorVoltage 0 %d 0 %f",*attr_DetectorIndex_read,w_val);
	Tango::DevString resp;
	resp = send_cmd(detectorvoltagecmd);
	CORBA::string_free(resp);
	DetectorVoltages[*attr_DetectorIndex_read]= w_val;

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::write_DetectorVoltage
}
//--------------------------------------------------------
/**
 *	Read attribute StartMass related method
 *	Description: Start Mass for Barchart scans.
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_StartMass(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_StartMass(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_StartMass) ENABLED START -----*/
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	attr.set_value(attr_StartMass_read);

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_StartMass
}
//--------------------------------------------------------
/**
 *	Write attribute StartMass related method
 *	Description: Start Mass for Barchart scans.
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::write_StartMass(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::write_StartMass(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevUShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::write_StartMass) ENABLED START -----*/
	if(properties_initialized == false)
	{
		Tango::Except::throw_exception(
		(const char *) "DeviceNotInitialized",
		(const char *) "Device not correctly initialized.",
		(const char *) "MKS_MicrovisionIP_RGA::write_StartMass()");
	}	
	string measurementselectcmd = "MeasurementSelect bar";
	Tango::DevString resp;
	resp = send_cmd(measurementselectcmd.c_str());
	CORBA::string_free(resp);
	
	char changestartmasscmd[30];
	snprintf(changestartmasscmd,30*sizeof(char),"MeasurementStartMass %d",w_val);
	resp = send_cmd(changestartmasscmd);
	CORBA::string_free(resp);
		
	if(strcasecmp(*attr_MeasurementMode_read,"Barchart") == 0)
	{
		try
		{
			resp = send_cmd("ScanRestart");
			CORBA::string_free(resp);
		}
		catch(Tango::DevFailed &e) { Tango::Except::print_exception(e); }

		omni_mutex_lock l(mutex);
		{
			for(int i =1; i<w_val; i++)
				Masses[i] = min_detectable_pressure;
		}
	}
	
	*attr_StartMass_read = w_val;
	
	Tango::DbData		data;
	data.clear();
	data.push_back(Tango::DbDatum("startMass"));
	try
	{
		data[0] << w_val;
		get_db_device()->put_property(data);
	}
	catch(...)
	{
		ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_StartMass: Error writing property in database" << endl;
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::write_StartMass
}
//--------------------------------------------------------
/**
 *	Read attribute EndMass related method
 *	Description: End Mass for Barchart scans.
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_EndMass(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_EndMass(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_EndMass) ENABLED START -----*/
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	attr.set_value(attr_EndMass_read);

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_EndMass
}
//--------------------------------------------------------
/**
 *	Write attribute EndMass related method
 *	Description: End Mass for Barchart scans.
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::write_EndMass(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::write_EndMass(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevUShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::write_EndMass) ENABLED START -----*/
	if(properties_initialized == false)
	{
		Tango::Except::throw_exception(
		(const char *) "DeviceNotInitialized",
		(const char *) "Device not correctly initialized.",
		(const char *) "MKS_MicrovisionIP_RGA::write_EndMass()");
	}	
	string measurementselectcmd = "MeasurementSelect bar";
	Tango::DevString resp;
	resp = send_cmd(measurementselectcmd.c_str());	
	CORBA::string_free(resp);
	char changeendmasscmd[30];
	snprintf(changeendmasscmd,30*sizeof(char),"MeasurementEndMass %d",w_val);
	resp = send_cmd(changeendmasscmd);
	CORBA::string_free(resp);
	
	if(strcasecmp(*attr_MeasurementMode_read,"Barchart") == 0)
	{
		try
		{
			resp = send_cmd("ScanRestart");
			CORBA::string_free(resp);
		}
		catch(Tango::DevFailed &e) { Tango::Except::print_exception(e); }
	
		omni_mutex_lock l(mutex);
		{
			for(int i = (w_val+1); i<=MaxMass; i++)
				Masses[i] = min_detectable_pressure;
		}
	}
	
	*attr_EndMass_read = w_val;
	
	Tango::DbData		data;
	data.clear();
	data.push_back(Tango::DbDatum("endMass"));
	try
	{
		data[0] << w_val;
		get_db_device()->put_property(data);
	}
	catch(...)
	{
		ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_EndMass: Error writing property in database" << endl;
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::write_EndMass
}
//--------------------------------------------------------
/**
 *	Read attribute LeakCheckMass related method
 *	Description: Mass scanned in Leakcheck mode.\n(SinglePeak scans).
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_LeakCheckMass(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_LeakCheckMass(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_LeakCheckMass) ENABLED START -----*/
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	attr.set_value(attr_LeakCheckMass_read);

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_LeakCheckMass
}
//--------------------------------------------------------
/**
 *	Write attribute LeakCheckMass related method
 *	Description: Mass scanned in Leakcheck mode.\n(SinglePeak scans).
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::write_LeakCheckMass(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::write_LeakCheckMass(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::write_LeakCheckMass) ENABLED START -----*/
	if(properties_initialized == false)
	{
		Tango::Except::throw_exception(
		(const char *) "DeviceNotInitialized",
		(const char *) "Device not correctly initialized.",
		(const char *) "MKS_MicrovisionIP_RGA::write_LeakCheckMass()");
	}	
	string measurementselectcmd = "MeasurementSelect sp";
	Tango::DevString resp;
	resp = send_cmd(measurementselectcmd.c_str());
	CORBA::string_free(resp);
	char changemasscmd[40];
	snprintf(changemasscmd,30*sizeof(char),"MeasurementMass %f",w_val);
	resp = send_cmd(changemasscmd);
	CORBA::string_free(resp);
	
	if(strcasecmp(*attr_MeasurementMode_read,"Leakcheck") == 0)
	{
		try
		{
			resp = send_cmd("ScanRestart");
			CORBA::string_free(resp);
		}
		catch(Tango::DevFailed &e)
		{
			ERROR_STREAM << " MKS_MicrovisionIP_RGA::write_LeakCheckMass(): ScanRestart command failed" << endl;
			{
				omni_mutex_lock l(mutex);
				scanstarted = false;
			}
			throw; 
		}
		for(int i =1; i<=MaxMass; i++)
		{
			omni_mutex_lock l(mutex);
			Masses[i] = min_detectable_pressure;
		}
	}	
	*attr_LeakCheckMass_read = w_val;
	
	Tango::DbData		data;
	data.clear();
	data.push_back(Tango::DbDatum("leakCheckMass"));
	try
	{
		data[0] << w_val;
		get_db_device()->put_property(data);
	}
	catch(...)
	{
		ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_LeakCheckMass: Error writing property in database" << endl;
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::write_LeakCheckMass
}
//--------------------------------------------------------
/**
 *	Read attribute Timeout related method
 *	Description: Maximum time in ms to wait before getting the response of a command.
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_Timeout(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_Timeout(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_Timeout) ENABLED START -----*/
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	attr.set_value(attr_Timeout_read);

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_Timeout
}
//--------------------------------------------------------
/**
 *	Write attribute Timeout related method
 *	Description: Maximum time in ms to wait before getting the response of a command.
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::write_Timeout(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::write_Timeout(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::write_Timeout) ENABLED START -----*/
	if(properties_initialized == false)
	{
		Tango::Except::throw_exception(
		(const char *) "DeviceNotInitialized",
		(const char *) "Device not correctly initialized.",
		(const char *) "MKS_MicrovisionIP_RGA::write_Timeout()");
	}
	attr.get_write_value(timeout);
	*attr_Timeout_read = timeout;
	timeout_secs = timeout / 1000;
	timeout_nanosecs = timeout * 1000000 - timeout_secs * 1000000000;
		
	Tango::DbData		data;
	data.clear();
	data.push_back(Tango::DbDatum("timeout"));
	try
	{
		data[0] << timeout;
		get_db_device()->put_property(data);
	}
	catch(...)
	{
		ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_Timeout: Error writing property in database" << endl;
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::write_Timeout
}
//--------------------------------------------------------
/**
 *	Read attribute Gain related method
 *	Description: Electronic gain Index to use for the measurements.
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_Gain(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_Gain(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_Gain) ENABLED START -----*/
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	attr.set_value(attr_Gain_read);

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_Gain
}
//--------------------------------------------------------
/**
 *	Write attribute Gain related method
 *	Description: Electronic gain Index to use for the measurements.
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::write_Gain(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::write_Gain(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevUShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::write_Gain) ENABLED START -----*/
	if(properties_initialized == false)
	{
		Tango::Except::throw_exception(
		(const char *) "DeviceNotInitialized",
		(const char *) "Device not correctly initialized.",
		(const char *) "MKS_MicrovisionIP_RGA::write_Gain()");
	}	
	string measurementselectcmd = "MeasurementSelect bar";
	Tango::DevString resp;
	resp = send_cmd(measurementselectcmd.c_str());
	CORBA::string_free(resp);

	char changegaincommand[30];
	snprintf(changegaincommand,30*sizeof(char),"MeasurementEGainIndex %d",w_val);
	resp = send_cmd(changegaincommand);
	CORBA::string_free(resp);
	
	measurementselectcmd = "MeasurementSelect sp";
	resp = send_cmd(measurementselectcmd.c_str());
	CORBA::string_free(resp);
	resp = send_cmd(changegaincommand);
	CORBA::string_free(resp);
	
	*attr_Gain_read = w_val;
	
	//Scanrestart
	try
	{
		resp = send_cmd("ScanRestart");
		CORBA::string_free(resp);
	}
	catch(Tango::DevFailed &e) { Tango::Except::print_exception(e); }
	
	Tango::DbData		data;
	data.clear();
	data.push_back(Tango::DbDatum("gain"));
	try
	{
		data[0] << w_val;
		get_db_device()->put_property(data);
	}
	catch(...)
	{
		ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_Gain: Error writing property in database" << endl;
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::write_Gain
}
//--------------------------------------------------------
/**
 *	Read attribute SourceIndex related method
 *	Description: Index of the source settings to use for measurement.\nThe MicroVision IP supports up to 6 sets of ion source \nparameters which can be configured to suit the hardware \nconfiguration and environment where the sensor is used.
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_SourceIndex(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_SourceIndex(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_SourceIndex) ENABLED START -----*/
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	attr.set_value(attr_SourceIndex_read);

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_SourceIndex
}
//--------------------------------------------------------
/**
 *	Write attribute SourceIndex related method
 *	Description: Index of the source settings to use for measurement.\nThe MicroVision IP supports up to 6 sets of ion source \nparameters which can be configured to suit the hardware \nconfiguration and environment where the sensor is used.
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::write_SourceIndex(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::write_SourceIndex(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevUShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::write_SourceIndex) ENABLED START -----*/
	if(properties_initialized == false)
	{
		Tango::Except::throw_exception(
		(const char *) "DeviceNotInitialized",
		(const char *) "Device not correctly initialized.",
		(const char *) "MKS_MicrovisionIP_RGA::write_SourceIndex()");
	}	
	string measurementselectcmd = "MeasurementSelect bar";
	Tango::DevString resp;
	resp = send_cmd(measurementselectcmd.c_str());
	CORBA::string_free(resp);

	char changesourcecommand[30];
	snprintf(changesourcecommand,30*sizeof(char),"MeasurementSourceIndex %d",w_val);
	resp = send_cmd(changesourcecommand);
	CORBA::string_free(resp);
	
	measurementselectcmd = "MeasurementSelect sp";
	resp = send_cmd(measurementselectcmd.c_str());
	CORBA::string_free(resp);
	resp = send_cmd(changesourcecommand);
	CORBA::string_free(resp);

	*attr_SourceIndex_read = w_val;
	Tango::DbData		data;
	data.clear();
	data.push_back(Tango::DbDatum("sourceIndex"));
	try
	{
		data[0] << w_val;
		get_db_device()->put_property(data);
	}
	catch(...)
	{
		ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_SourceIndex: Error writing property in database" << endl;
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::write_SourceIndex
}
//--------------------------------------------------------
/**
 *	Read attribute FilterMode related method
 *	Description: Specifies how each AMU should be scanned and turned into a single reading:\n- PeakCenter:    Single point at the nominal peak center is measured\n- PeakMax:       Central 1/2 AMU scanned and the max value reported\n- PeakAverage: Central 1/2 AMIU scanned and the average value reported
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_FilterMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_FilterMode(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_FilterMode) ENABLED START -----*/
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	attr.set_value(attr_FilterMode_read);

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_FilterMode
}
//--------------------------------------------------------
/**
 *	Write attribute FilterMode related method
 *	Description: Specifies how each AMU should be scanned and turned into a single reading:\n- PeakCenter:    Single point at the nominal peak center is measured\n- PeakMax:       Central 1/2 AMU scanned and the max value reported\n- PeakAverage: Central 1/2 AMIU scanned and the average value reported
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::write_FilterMode(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::write_FilterMode(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::write_FilterMode) ENABLED START -----*/
	if(properties_initialized == false)
	{
		Tango::Except::throw_exception(
		(const char *) "DeviceNotInitialized",
		(const char *) "Device not correctly initialized.",
		(const char *) "MKS_MicrovisionIP_RGA::write_FilterMode()");
	}	
	
	if(strcasecmp(w_val,*attr_FilterMode_read) == 0)
	{
		// we are already in this filter mode
		return;
	}
	string measurementselectcmd = "MeasurementSelect bar";
	Tango::DevString resp;
	resp = send_cmd(measurementselectcmd.c_str());
	CORBA::string_free(resp);

	char changefiltermodecommand[40];
	snprintf(changefiltermodecommand,40*sizeof(char),"MeasurementFilterMode %s",w_val);
	resp = send_cmd(changefiltermodecommand);
	CORBA::string_free(resp);
	
	strcpy(*attr_FilterMode_read,w_val);

	Tango::DbData		data;
	data.clear();
	data.push_back(Tango::DbDatum("filterMode"));
	try
	{
		data[0] << w_val;
		get_db_device()->put_property(data);
	}
	catch(...)
	{
		ERROR_STREAM << "MKS_MicrovisionIP_RGA::write_FilterMode: Error writing property in database" << endl;
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::write_FilterMode
}
//--------------------------------------------------------
/**
 *	Read attribute LeakCheckPressure related method
 *	Description: This is the pressure of the mass defined by the LeakCheckMass attribute.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_LeakCheckPressure(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_LeakCheckPressure(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_LeakCheckPressure) ENABLED START -----*/
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	if(strcasecmp(*attr_MeasurementMode_read,"LeakCheck") == 0)
	{
		{
			omni_mutex_lock l(mutex);
			*attr_LeakCheckPressure_read = Masses[(unsigned int) round(*attr_LeakCheckMass_read)];
		}
		attr.set_value(attr_LeakCheckPressure_read);
	}
	else
	{
		attr.set_quality(Tango::ATTR_INVALID);
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_LeakCheckPressure
}
//--------------------------------------------------------
/**
 *	Read attribute DegasStatus related method
 *	Description: Status of the degassing process
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_DegasStatus(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_DegasStatus(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_DegasStatus) ENABLED START -----*/
	CORBA::string_free(*attr_DegasStatus_read);
	{
		omni_mutex_lock l(mutex);
		*attr_DegasStatus_read = CORBA::string_dup(degas_status.c_str());
	}
	attr.set_value(attr_DegasStatus_read);

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_DegasStatus
}
//--------------------------------------------------------
/**
 *	Read attribute FilamentDegas related method
 *	Description: When this attribute is set to true, it will start the degassing process on the \ncurrent selected filament.\nThe attribute will stay true until the filament degassing process will end.\nWhen this attribute is set to false, it will call the StopDegas command.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_FilamentDegas(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_FilamentDegas(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_FilamentDegas) ENABLED START -----*/
	{
		omni_mutex_lock l(mutex);
		attr.set_value(attr_FilamentDegas_read);
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_FilamentDegas
}
//--------------------------------------------------------
/**
 *	Write attribute FilamentDegas related method
 *	Description: When this attribute is set to true, it will start the degassing process on the \ncurrent selected filament.\nThe attribute will stay true until the filament degassing process will end.\nWhen this attribute is set to false, it will call the StopDegas command.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::write_FilamentDegas(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::write_FilamentDegas(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::write_FilamentDegas) ENABLED START -----*/
	if(w_val)
		start_degas();
	else
		stop_degas();

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::write_FilamentDegas
}
//--------------------------------------------------------
/**
 *	Read attribute LifetimePressure related method
 *	Description: Apparent pressure contributing to the lifetime.\nThis is the weighted sum of partial pressures * Z^2
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_LifetimePressure(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_LifetimePressure(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_LifetimePressure) ENABLED START -----*/
	//	{
//		omni_mutex_lock l(mutex);
//		attr_Masses << Masses;
//	}
	LifetimePressure = 0;
	for(unsigned int i = 2; i <Masses.size(); i++) 
	{
		if(Masses[i] > 2.0e-12) LifetimePressure = LifetimePressure + (Masses[i] * (double)i * (double)(1 + i));
	}
	attr.set_value(&LifetimePressure);

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_LifetimePressure
}
//--------------------------------------------------------
/**
 *	Read attribute Masses related method
 *	Description: 
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Spectrum max = 101
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_Masses(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_Masses(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_Masses) ENABLED START -----*/
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	{
		omni_mutex_lock l(mutex);
		attr_Masses << Masses;
	}
	attr.set_value(attr_Masses.get_buffer(),attr_Masses.length());

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_Masses
}
//--------------------------------------------------------
/**
 *	Read attribute MassesHistory related method
 *	Description: This attribute is the same as the Masses attribute and was \ncreated to be able to have another polling period and a buffer history.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Spectrum max = 101
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_MassesHistory(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_MassesHistory(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_MassesHistory) ENABLED START -----*/
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	{
		omni_mutex_lock l(mutex);
		attr_Masses << Masses;
	}
	attr.set_value(attr_Masses.get_buffer(),attr_Masses.length());

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_MassesHistory
}
//--------------------------------------------------------
/**
 *	Read attribute StaticPressures related method
 *	Description: spectrum of pressure taken when beam is at 0.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Spectrum max = 101
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_StaticPressures(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_StaticPressures(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_StaticPressures) ENABLED START -----*/
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	{
		omni_mutex_lock l(mutex);
		attr_StaticPressures << staticPressures;
		attr_StaticPressures[0] = sqrt(-1.2); // Mass[0] should be NaN
	}
	attr.set_value(attr_StaticPressures.get_buffer(),attr_StaticPressures.length());

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_StaticPressures
}

//--------------------------------------------------------
/**
 *	Read attribute MassScalarAttrib related method
 *	Description: 
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_MassScalarAttrib(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_MassScalarAttrib(Tango::Attribute &attr) entering... " << endl;
	Tango::DevDouble	*att_value = get_MassScalarAttrib_data_ptr(attr.get_name());
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::read_MassScalarAttrib) ENABLED START -----*/
	//	Set the attribute value
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	string &attr_name = attr.get_name();
	DEBUG_STREAM << "In read_Mass() for attribute " << attr_name << endl;
	int MassNumber = atoi(attr_name.c_str()+4);
	{
		omni_mutex_lock l(mutex);
		*att_value = Masses[MassNumber];
		attr.set_value(att_value);
	}
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::read_MassScalarAttrib
}
//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGA::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::add_dynamic_attributes()
{
	//	Example to add dynamic attribute:
	//	Copy inside the following protected area to create instance(s) at startup.
	//	add_MassScalarAttrib_dynamic_attribute("MyMassScalarAttribAttribute");
	
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	// loop over the list of attributes to be created!
	for (int i = 1; i <= MaxMass ; i++)
	{
		TangoSys_OMemStream     tms;
		tms << "Mass" << i;
		add_MassScalarAttrib_dynamic_attribute(tms.str());

		/*
		mass = new MassScalarAttrib (attrname,Tango::DEV_DOUBLE,Tango::READ);
		Tango::UserDefaultAttrProp      mass_prop;
		sprintf(strtmp,"Mass %d",i);
		mass_prop.set_label(strtmp);
		mass_prop.set_unit("mBar");
		mass_prop.set_standard_unit(" ");
		mass_prop.set_display_unit(" ");
		mass_prop.set_format("%.3e");
		sprintf(strtmp,"AMU %d",i);
		mass_prop.set_description(strtmp);
		mass->set_default_properties(mass_prop);
		mass->set_disp_level(Tango::EXPERT);
		mass->set_change_event(true,false);
		mass->set_archive_event(true,true);
		att_list.push_back(mass);
		//cout << attrname << " created" << endl;
	*/
	}
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command State related method
 *	Description: This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 *	@returns State Code
 */
//--------------------------------------------------------
Tango::DevState MKS_MicrovisionIP_RGA::dev_state()
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::State()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::dev_state) ENABLED START -----*/
	
	Tango::DevState	argout = Tango::UNKNOWN; // replace by your own algorithm
	//	Add your own code
	if(properties_initialized == false)
	{
		struct timeval now;
		gettimeofday(&now,NULL);
		if(now.tv_sec - last_measure_time.tv_sec > time_until_reinit)
		{
			try
			{
cerr << "Calling delete_device(), init_device() from DevState nb 1" << endl;
				delete_device();
				init_device();
			}
			catch(Tango::DevFailed &e)
			{
				set_state(Tango::UNKNOWN);
				ERROR_STREAM << "MKS_MicrovisionIP_RGA::dev_state(): Error when reinitializing parameters" << endl;
			}
		}
		return Tango::UNKNOWN;
	}
	// send command SensorState
	string senstate= sensorstate;
	if((released == true) || (strcasecmp(senstate.c_str(),"InUse") == 0))
	{
			// The Unit is currently in use by someone
			argout = Tango::DISABLE;
	}	
	else if(strcasecmp(senstate.c_str(),"Config") == 0)
	{
		// The Unit requires configuring and is unavailable to most applications
		argout = Tango::FAULT;	
	}
	else if(strcasecmp(senstate.c_str(),"N/A") == 0)
	{
		// The Unit is unavailable
		argout = Tango::FAULT;
	}
	else if(strcasecmp(senstate.c_str(),"Ready") == 0)
	{
		// The Unit is Ready for use
		bool rf_tripped;
		bool scanning = false;
		short link_down = LINK_DOWN_OK;
		struct timeval last_measure_timeval;
		{
			omni_mutex_lock l(mutex);
			link_down = linkdown;
			rf_tripped = RFTripped;
			last_measure_timeval = last_measure_time;
		}
		struct timeval now;
		gettimeofday(&now,NULL);
		if(now.tv_sec - last_measure_timeval.tv_sec > MAX_ACQUISITION_TIME)
		{
			if(*attr_FilamentDegas_read == false)
			{
				scanning = false;  /* data too old,older than MAX_ACQUISITION_TIME seconds*/
				if(now.tv_sec - last_measure_timeval.tv_sec > time_until_reinit)
				{
					try
					{
cerr << "Calling delete_device(), init_device() from DevState nb 2" << endl;
						delete_device();
						init_device();
					}
					catch(Tango::DevFailed &e)
					{
						ERROR_STREAM << "MKS_MicrovisionIP_RGA::dev_state(): Error when reinitializing parameters" << endl;
					}
				}
			}
		}
		else
		{
			scanning = true;
		}
		if((rf_tripped == true) || (link_down != LINK_DOWN_OK) || ((*attr_FilamentDegas_read == false)&&(scanning == false)) || (manual_reset_needed == true))
		{
			argout = Tango::FAULT;
		}
		else
		{
			// check the state of the filament and the multiplier
			string filstate = "Unknown";
			{
				omni_mutex_lock l(mutex);
				filstate = FilamentState;
			}
			if(strcasecmp(filstate.c_str(),"BAD-EMISSION") == 0)
			{
				// Bad emission => FAULT
				argout = Tango::FAULT;
			}
			else if(strcasecmp(filstate.c_str(),"OFF") == 0)
			{
				// Filament OFF => OFF || FAULT
				if(FilamentTripReason == "None")
					argout = Tango::OFF;
				else
					argout = Tango::FAULT;
			}
			else if((strcasecmp(filstate.c_str(),"WARM-UP") == 0) || (strcasecmp(filstate.c_str(),"COOL-DOWN")== 0))
			{
				// Filament WARM-UP => STANDBY || FAULT
				if(FilamentTripReason == "None")
					argout = Tango::STANDBY;
				else
					argout = Tango::FAULT;
				
			}
			else if(strcasecmp(filstate.c_str(),"ON") == 0)
			{
				if(*attr_FilamentDegas_read == true)
				{
					set_state(Tango::MOVING);
					return Tango::MOVING;
				}
				// check Multiplier state
				string multstate = "Unknown";
				{
					omni_mutex_lock l(mutex);
					multstate = MultiplierState;
				}
				if(strcasecmp(multstate.c_str(), "Off") == 0)
				{
					// Multiplier OFF => STANDBY		
					argout = Tango::STANDBY;
				}
				else
				{
					// Multiplier ON => 
					// check ScanningMode
					if(strcasecmp(*attr_MeasurementMode_read,"Barchart") != 0)
					{
						// if scanningMode != barchart => MOVING 
						argout = Tango::MOVING;
					}
					else
					{
						// else check if we are scanning
						bool scanning = false;
						{
							omni_mutex_lock l(mutex);
							scanning = scanstarted;
						}	
						if(scanning == false)
						{
							argout = Tango::FAULT;
						}
						else
						{
							// check if there is a mass > min_detectable_pressure
							bool ok = false;
							int m = *attr_StartMass_read;
							{
								omni_mutex_lock l(mutex);
								while((!ok) && m <= *attr_EndMass_read)
								{
									if(Masses[m] > min_detectable_pressure)
										ok = true;
									m++;
								}
							}
							if(ok)
								argout = Tango::ON;
							else
								argout = Tango::ALARM;
						}
					}
				}
			}
		}
	}
	else
	{
		Tango::DevString resp;
		try
		{
			resp = send_cmd("SensorState");
		}
		catch(Tango::DevFailed &e)
		{
			Tango::Except::print_exception(e);
			struct timeval last_measure_timeval;
			{
				omni_mutex_lock l(mutex);
				last_measure_timeval = last_measure_time;
			}
			struct timeval now;
			gettimeofday(&now,NULL);
			if(now.tv_sec - last_measure_timeval.tv_sec > time_until_reinit)
			{
				try
				{
cerr << "Calling delete_device(), init_device() from DevState nb 3" << endl;
					delete_device();
					init_device();
				}
				catch(Tango::DevFailed &e)
				{
					Tango::Except::print_exception(e);
				}
				return Tango::UNKNOWN;
			}
			else
			{
				set_state(Tango::UNKNOWN);
				argout = DeviceImpl::dev_state();
				return argout;
			}
		}
		
		istringstream stateresp(resp);
		string strtmp = "";
		stateresp >> strtmp; //SensorState
		stateresp >> strtmp; // OK
		stateresp >> strtmp; // State
		stateresp >> sensorstate;
		CORBA::string_free(resp);
		if(strcasecmp(sensorstate.c_str(),"Ready") == 0)
		{
			// we can init our parameters
			try
			{
cerr << "Calling delete_device(), init_device() from DevState nb 4" << endl;	
				delete_device();
				init_device();
			}
			catch(Tango::DevFailed &e)
			{
				ERROR_STREAM << "MKS_MicrovisionIP_RGA::dev_state(): error initializing parameters" << endl;
				argout = Tango::UNKNOWN;
			}
		}
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::dev_state
	set_state(argout);    // Give the state to Tango.
	if (argout!=Tango::ALARM)
		Tango::DeviceImpl::dev_state();
	return get_state();  // Return it after Tango management.
}
//--------------------------------------------------------
/**
 *	Command Status related method
 *	Description: This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *
 *	@returns Status description
 */
//--------------------------------------------------------
Tango::ConstDevString MKS_MicrovisionIP_RGA::dev_status()
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::Status()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::dev_status) ENABLED START -----*/
	
	string	status = "Device is OK";
	//	Add your own code
	thestatus = "";
	if(properties_initialized == false)
	{
		thestatus = "UNKNOWN:\n";
		thestatus += "The device is not correctly initialized\n";
		thestatus += "Please check that the Tango database is reachable and execute the init command\n";
		thestatus += "Or restart the device server";
		set_status(thestatus.c_str());
		Tango::ConstDevString	argout = thestatus.c_str();
		return argout;
	}
	if(released)
	{
		thestatus = "The sensor has been released\n";
		thestatus += "Use Init command if you want to take control again\n";
		set_status(thestatus.c_str());
		Tango::ConstDevString	argout = thestatus.c_str();
		return argout;
	}
	
	if(strcasecmp(sensorstate.c_str(),"Ready") != 0)
	{
		Tango::DevString resp;
		try
		{
			resp = send_cmd("SensorState");
		}
		catch(Tango::DevFailed &e)
		{
			Tango::Except::print_exception(e);
			thestatus = "Cannot get sensor state, communication problem\n Network problem?";
			set_status(thestatus.c_str());
			set_state(Tango::UNKNOWN);
			Tango::ConstDevString	argout = thestatus.c_str();
			return argout;
		}
		istringstream stateresp(resp);
		string strtmp = "";
		stateresp >> strtmp; //SensorState
		stateresp >> strtmp; // OK
		stateresp >> strtmp; // State
		stateresp >> sensorstate;
		CORBA::string_free(resp);
		if(strcasecmp(sensorstate.c_str(),"Ready") == 0)
		{
			// we can init our parameters
			try
			{	
cerr << "Calling delete_device(), init_device() from Status cmd" << endl;
				delete_device();
				init_device();
			}
			catch(Tango::DevFailed &e)
			{
				ERROR_STREAM << "MKS_MicrovisionIP_RGA::dev_status(): error initializing parameters" << endl;
				thestatus = sensorstate + "\n";
			}
		}
		else if(strcasecmp(sensorstate.c_str(),"InUse") == 0)
		{
			  /////////////////////////////////////////////
			 // The Unit is currently in use by someone //
			/////////////////////////////////////////////
			string UserAppli = "";
			string UserVersion = "";
			string UserAddress = "";
			stateresp >> strtmp; // UserApplication
			stateresp >> UserAppli;
			stateresp >> strtmp; // UserVersion
			stateresp >> UserVersion;
			stateresp >> strtmp; // UserAddress
			stateresp >> UserAddress;
			thestatus = "The Unit is currently in use by :\n\tUserApplication: ";
			thestatus += UserAppli;
			thestatus += "\n\tUserVersion: ";
			thestatus += UserVersion;
			thestatus += "\n\tUserAddress: ";
			thestatus += UserAddress;
			thestatus += "\n";
		}
		else if(strcasecmp(sensorstate.c_str(),"Config") == 0)
		{
			  //////////////////////////////////////////////////////
			 // The unit requires configuring and is unavailable //
			//////////////////////////////////////////////////////
			thestatus = "The unit requires configuring and is unavailable\n";
			set_state(Tango::FAULT);
		}
		else if(strcasecmp(sensorstate.c_str(),"N/A") == 0)
		{
			 //////////////////////////////
			 // The unit is unavailable //
			/////////////////////////////
			thestatus = "The unit is unavailable\n";
			set_state(Tango::FAULT);
		}
		else
		{
			thestatus = "Unknown\n";
			set_state(Tango::UNKNOWN);
		}
		set_status(thestatus.c_str());
		Tango::ConstDevString	argout = thestatus.c_str();
		return argout;
	}
	else
	{
		  ///////////////////////////////////	
		 //	 The Unit is Ready for use  //
		///////////////////////////////////
		bool scanning = false;
		bool rftripped = false;
		struct timeval last_measure_timeval;
		short link_down = LINK_DOWN_OK;
		{
			omni_mutex_lock l(mutex);
			if(RFTripped)
				rftripped = true;
			scanning = scanstarted;
			link_down = linkdown;
			last_measure_timeval = last_measure_time;
		}
		struct timeval now;
		gettimeofday(&now,NULL);
		if(now.tv_sec - last_measure_timeval.tv_sec > MAX_ACQUISITION_TIME )
			scanning = false; /* data too old,older than MAX_ACQUISITION_TIME seconds*/
		if(scanning)
		{
			thestatus = sensorstate + "\n";
		}
		else
		{
			if(*attr_FilamentDegas_read == true)
				thestatus = "Filament Degassing\n";
			else
				thestatus = "Fault: Not Scanning\n";
			// check the state of the socket device
			Tango::DevState socketstate = Tango::UNKNOWN;
			if(Socketds != NULL)
			{
				try
				{
					Tango::DeviceAttribute sockstate = Socketds->read_attribute("State");
					sockstate >> socketstate;
				}
				catch(Tango::DevFailed &e)
				{
					Tango::Except::print_exception(e);
					thestatus = "Communication problem with the socket device";
					set_status(thestatus.c_str());
					set_state(Tango::UNKNOWN);
					Tango::ConstDevString	argout = thestatus.c_str();
					return argout;
				}
			}
			if(socketstate != Tango:: ON)
			{
				set_state(Tango::UNKNOWN);
				thestatus = "Communication problem (Network problem ?)";
				set_status(thestatus.c_str());
				Tango::ConstDevString	argout = thestatus.c_str();
				return argout;
			}
			set_state(Tango::FAULT);
		}
		if(rftripped)
		{
			set_state(Tango::FAULT);
			thestatus += "Fault: RF tripped\n";
		}
			
		if(link_down == LINK_DOWN_OK)
		{
			// no pb
		}
		else if(link_down == LINK_DOWN_SERIAL)
		{
			thestatus += "Fault: The serial link between a PC and the MicroVision+ sensor has been lost\n";
			set_state(Tango::UNKNOWN);
		}
		else if(link_down == LINK_DOWN_VSC)
		{
			thestatus += "Fault: The link between a MicroVision IP and it's VSC has been lost.\n";
			thestatus += "Until the link can be made again it won't be possible to control the sensor\n";
			set_state(Tango::UNKNOWN);
		}

	}
	thestatus += "Measurement Mode: ";
 	thestatus += *attr_MeasurementMode_read;
	thestatus += "\n";
	string FilTripReason = "None";
	{
		omni_mutex_lock l(mutex);
		thestatus = thestatus + "Filament " + ActiveFilament + " " + FilamentState;
		FilTripReason = FilamentTripReason;
	}
	if(FilTripReason != "None")
	{
		if(FilTripReason == "Emission")
			thestatus += "\nFilaments tripped due to bad emission";
		else if(FilTripReason == "External")
			thestatus += "\nThe external trip line caused the filaments to go off\n";
		else if(FilTripReason == "RVC")
			thestatus += "\nThe RVC caused filaments to trip\n";
	}
	
	
	{
		omni_mutex_lock l(mutex);
		thestatus = thestatus + "\nMultiplierState " + MultiplierState;
	}

	if(manual_reset_needed == true)
	{
		thestatus = "\nFault: Error 500 - Failed to create measurement\n!!! The RGA must be reset manually !!!\n" + thestatus;
	}
	
	set_status(thestatus.c_str());
	Tango::ConstDevString	argout = thestatus.c_str();

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::dev_status
	set_status(status);               // Give the status to Tango.
	return Tango::DeviceImpl::dev_status();  // Return it.
}
//--------------------------------------------------------
/**
 *	Command On related method
 *	Description: Switch On the selected filament.
 *
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::on()
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::On()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::on) ENABLED START -----*/
	
	//	Add your own code
	if(properties_initialized == false)
	{
		Tango::Except::throw_exception(
		(const char *) "DeviceNotInitialized",
		(const char *) "Device not correctly initialized. Please try the INIT command",
		(const char *) "MKS_MicrovisionIP_RGA::on()");
	}
	Tango::DevString resp;
	resp = send_cmd("FilamentControl On");
	CORBA::string_free(resp);
	{
		omni_mutex_lock l(mutex);
		FilamentTripReason = "None";
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::on
}
//--------------------------------------------------------
/**
 *	Command Off related method
 *	Description: Switch Off the selected filament.
 *
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::off()
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::Off()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::off) ENABLED START -----*/
	
	//	Add your own code
	if(properties_initialized == false)
	{
		Tango::Except::throw_exception(
		(const char *) "DeviceNotInitialized",
		(const char *) "Device not correctly initialized. Please try the INIT command",
		(const char *) "MKS_MicrovisionIP_RGA::off()");
	}
	Tango::DevString resp;
	resp = send_cmd("FilamentControl Off");
	CORBA::string_free(resp);

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::off
}
//--------------------------------------------------------
/**
 *	Command Reset related method
 *	Description: Reset the faults.
 *               If you want to initialise the unit in the predefined state and parameters, please use Init command.
 *
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::reset()
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::Reset()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::reset) ENABLED START -----*/
	
	//	Add your own code
	if(properties_initialized == false)
	{
		Tango::Except::throw_exception(
		(const char *) "DeviceNotInitialized",
		(const char *) "Device not correctly initialized. Please try the INIT command",
		(const char *) "MKS_MicrovisionIP_RGA::reset()");
	}
	{
		omni_mutex_lock l(mutex);
		RFTripped = false;
		linkdown = LINK_DOWN_OK;
		FilamentTripReason = "None";
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::reset
}
//--------------------------------------------------------
/**
 *	Command SendCmd related method
 *	Description: This command will send the command given in parameter to the RGA and return the anwer
 *               from the RGA as it.
 *
 *	@param argin Command to send to RGA
 *	@returns Response from RGA
 */
//--------------------------------------------------------
Tango::DevString MKS_MicrovisionIP_RGA::send_cmd(Tango::DevString argin)
{
	Tango::DevString argout;
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::SendCmd()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::send_cmd) ENABLED START -----*/
	
	//	Add your own code
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::send_cmd(): entering... !" << endl;

	//	Add your own code to control device here
	if(Socketds == NULL)
	{
		TangoSys_OMemStream o;
		o << "Socket device " << socket_device << " not initialized, maybe there was a problem with the Tango database?" << ends;
		Tango::Except::throw_exception(
		(const char *) "SocketDeviceNotInitialized",
		o.str(),
		(const char *) "MKS_MicrovisionIP_RGA::send_cmd(Tango::DevString)");
		
	}
	
	string RGAcmd = argin;
#ifdef ASTELNET
	cout << RGAcmd << endl;
#endif
	try
	{
		{
			omni_mutex_lock l(mutex);
			RGA_Answer = "";
		}
		Tango::DeviceData in;
		in << RGAcmd;
		Socketds->command_inout("Write",in);
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
	}
	string str_ack = "";
	istringstream cmdstream(argin);
	string cmdname = "";
	cmdstream >> cmdname; // first word = command name
	check_ACK(str_ack,cmdname.c_str(),timeout_secs,timeout_nanosecs);
	argout = CORBA::string_dup(str_ack.c_str());

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::send_cmd
	return argout;
}
//--------------------------------------------------------
/**
 *	Command Release related method
 *	Description: Release the control of the RGA.
 *               Use this command only if you want to use another program than the Tango Device server to control the RGA.
 *
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::release()
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::Release()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::release) ENABLED START -----*/
	
	//	Add your own code
	if(properties_initialized == false)
	{
		Tango::Except::throw_exception(
		(const char *) "DeviceNotInitialized",
		(const char *) "Device not correctly initialized. Please try the INIT command",
		(const char *) "MKS_MicrovisionIP_RGA::release()");
	}
	Tango::DevString resp;
	resp = send_cmd("Release");
	CORBA::string_free(resp);
	struct timeval when;
	gettimeofday(&when,NULL);
	Tango::DevDouble value = min_detectable_pressure;
	for(int i =1; i<=MaxMass; i++)
	{
		Tango::AttrHistoryStack<Tango::DevDouble> chs;
		chs.length(1);
		TangoSys_OMemStream o;
		o << "Mass" << i;
		string attr_name = o.str();
		if(tg == NULL)
			tg = Tango::Util::instance(false);
		try
		{
			
			Tango::TimedAttrData<Tango::DevDouble> tcd(&value,when);
			chs.push(tcd);
			tg->fill_attr_polling_buffer(this,attr_name,chs);
		}
		catch(Tango::DevFailed &e)
		{
			Tango::Except::print_exception(e);
		}
		if(attr_list == NULL)
			attr_list = get_device_attr();
		Tango::Attribute &att_mass = attr_list->get_attr_by_name (attr_name.c_str());
		try
		{		 
			// set the new values and fire the change event 
			omni_mutex_lock l(mutex);
			*(attr_Mass_read[(unsigned int)i]) = Masses[(unsigned int)i] = value;
 			att_mass.set_value(attr_Mass_read[(unsigned int)i]);
			att_mass.fire_change_event ();
		}
		catch (Tango::DevFailed &e)
		{
			Tango::Except::print_exception(e);
			att_mass.fire_change_event (&e);
		}
		try
		{		 
			// set the new values and fire the archive event 
			omni_mutex_lock l(mutex);
			*(attr_Mass_read[(unsigned int)i]) = value;
			att_mass.set_value(attr_Mass_read[(unsigned int)i]);
 			att_mass.fire_archive_event ();
		}
		catch (Tango::DevFailed &e)
		{
			Tango::Except::print_exception(e);
//			att_mass.fire_archive_event (&e);
		}
	}
	released = true;

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::release
}
//--------------------------------------------------------
/**
 *	Command StartDegas related method
 *	Description: Start the filament degassing process
 *
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::start_degas()
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::StartDegas()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::start_degas) ENABLED START -----*/
	
	//	Add your own code
	// Stop the scan before starting degassing
	Tango::DevString resp_scanstop;
	try
	{
		resp_scanstop = send_cmd("ScanStop");
		CORBA::string_free(resp_scanstop);
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	}
	// switch on the selected filament
	on();
	// send StartDegas command with the parameters defined as properties
	char startdegascmd [100];
	snprintf(startdegascmd,100*sizeof(char),"StartDegas %d %d %d %d %d",degas_start_power,degas_end_power,degas_ramp_period,degas_max_power_period,degas_resettle_period);
	Tango::DevString resp;
	try
	{
		resp = send_cmd(startdegascmd);
		CORBA::string_free(resp);
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	}
	{
		omni_mutex_lock l(mutex);
		*attr_FilamentDegas_read = true;
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::start_degas
}
//--------------------------------------------------------
/**
 *	Command StopDegas related method
 *	Description: Stop the filament degassing process.
 *
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::stop_degas()
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::StopDegas()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::stop_degas) ENABLED START -----*/
	
	//	Add your own code
	Tango::DevString resp;
	try
	{
		resp = send_cmd("StopDegas");
		CORBA::string_free(resp);
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	}
	{
		omni_mutex_lock l(mutex);
		*attr_FilamentDegas_read = false;
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::stop_degas
}
//--------------------------------------------------------
/**
 *	Command StoreStaticPress related method
 *	Description: store the static pressure. this is autorized only if the SR current is 0.
 *
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::store_static_press()
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::StoreStaticPress()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::store_static_press) ENABLED START -----*/
	
	//	Add your own code
	Tango::DbData		data;
	data.clear();
	data.push_back(Tango::DbDatum("StaticPressures"));
	Masses[0] = 0; // to avoid problem when re-reading property
	try
	{
		data[0] << Masses;
		get_db_device()->put_property(data);
		staticPressures = Masses;
	}
	catch(...)
	{
		ERROR_STREAM << "MKS_MicrovisionIP_RGA::Store_static_press: Error writing property in database" << endl;
	}

	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::store_static_press
}
//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGA::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGA::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::add_dynamic_commands
}

/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGA::namespace_ending) ENABLED START -----*/

//	Additional Methods
//+----------------------------------------------------------------------------
//
// method : 		MKS_MicrovisionIP_RGA::read_Mass
// 
// description : 	Extract real attribute values for Mass acquisition result.
//
//-----------------------------------------------------------------------------
void MKS_MicrovisionIP_RGA::read_Mass(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::read_Mass(Tango::Attribute &attr) entering... "<< endl;
	if(properties_initialized == false)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	string &attr_name = attr.get_name();
	DEBUG_STREAM << "In read_Mass() for attribute " << attr_name << endl;
	int MassNumber = atoi(attr_name.c_str()+4);
	{
		omni_mutex_lock l(mutex);
		attr.set_value(&(Masses[MassNumber]));
	}
}
//+------------------------------------------------------------------
/**
 *	method:	MKS_MicrovisionIP_RGA::check_ACK
 *
 *	description:	method to check if a command cmd was correctly ACKNOWLEDGED
 *
 * @return	true if correct ACK
 *				false otherwise
 *
 */
//+------------------------------------------------------------------
bool MKS_MicrovisionIP_RGA::check_ACK(string &RGA_Ans, const char * command,unsigned long secs_rel, unsigned long nanosecs_rel)
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::check_ACK(): entering... !" << endl;
	
	unsigned long secs_abs, nanosecs_abs;
	
	omni_thread::get_time(&secs_abs,&nanosecs_abs,secs_rel,nanosecs_rel);
	if(command_cond->timedwait(secs_abs, nanosecs_abs))
	{
		omni_mutex_lock l(mutex);
		RGA_Ans = RGA_Answer;
	}
	else
	{
		TangoSys_OMemStream o;
		o << "Timeout waiting for Acknowledge for command " << command << ends;
		DEBUG_STREAM << "MKS_MicrovisionIP_RGA::check_ACK(): exiting... !" << endl;
		Tango::Except::throw_exception 
		((const char *)"Timeout",
		o.str(),
		(const char *)"MKS_MicrovisionIP_RGA::check_ACK()");
	}
	
	istringstream cmdack(RGA_Ans);
	string cmd = "";
	cmdack >> cmd;
	if(strcasecmp(cmd.c_str(),command) != 0)
	{
		ERROR_STREAM << "Bad Acknowledge: got " << cmd << ", " << command << " expected" << endl;
		TangoSys_OMemStream o;
		o << "Bad ACK for " << command << " command" << endl;
		DEBUG_STREAM << "MKS_MicrovisionIP_RGA::check_ACK(): exiting... !" << endl;
		Tango::Except::throw_exception 
		((const char *)"BadAcknowledge",
		o.str(),
		(const char *)"MKS_MicrovisionIP_RGA::check_ACK()");
		
	}
	string OK = "";
	cmdack >> OK;
	if(strcasecmp(OK.c_str(),"OK") == 0)
	{
		DEBUG_STREAM << "" << command << " " << OK << endl;
		DEBUG_STREAM << "MKS_MicrovisionIP_RGA::check_ACK(): exiting... !" << endl;
		return  true;
	}
	else if(strcasecmp(OK.c_str(),"ERROR") == 0)
	{
		ERROR_STREAM << command << " ERROR " << endl;
		ERROR_STREAM << RGA_Ans << endl;
		TangoSys_OMemStream o;
		o << RGA_Ans << endl;
		DEBUG_STREAM << "MKS_MicrovisionIP_RGA::check_ACK(): exiting... !" << endl;
		Tango::Except::throw_exception 
		((const char *)"CommandError",
		o.str(),
		(const char *)"MKS_MicrovisionIP_RGA::check_ACK()");
	}
	else
	{
		TangoSys_OMemStream o;
		o << "Bad ACK for " << command << " command" << endl;
		DEBUG_STREAM << "MKS_MicrovisionIP_RGA::check_ACK(): exiting... !" << endl;
		Tango::Except::throw_exception 
		((const char *)"BadAcknowledge",
		o.str(),
		(const char *)"MKS_MicrovisionIP_RGA::check_ACK()");
	}
}
//+------------------------------------------------------------------
/**
 *	method:	MKS_MicrovisionIP_RGA::send_cmd
 *
 *	description:	method to execute "SendCmd"
 *	This command will send the command given in parameter to the RGA and return the anwer
 *	from the RGA as it.
 *
 * @param	argin	Command to send to RGA
 * @return	Response from RGA
 *
 */
//+------------------------------------------------------------------
Tango::DevString MKS_MicrovisionIP_RGA::send_cmd(const char * argin)
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::send_cmd(): entering... !" << endl;
	//	Add your own code to control device here
	if(Socketds == NULL)
	{
		TangoSys_OMemStream o;
		o << "Socket device " << socket_device << " not initialized, maybe there was a problem with the Tango database?" << ends;
		Tango::Except::throw_exception(
		(const char *) "SocketDeviceNotInitialized",
		o.str(),
		(const char *) "MKS_MicrovisionIP_RGA::send_cmd(const char *)");
		
	}
	
#ifdef ASTELNET
	printf("%s\n",argin);
#endif
	
	try
	{
		{
			omni_mutex_lock l(mutex);
			RGA_Answer = "";
		}
		Tango::DeviceData in;
		in << argin;
		Socketds->command_inout("Write",in);
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
	}
	string str_ack = "";
	istringstream cmdstream(argin);
	string cmdname = "";
	cmdstream >> cmdname; // first word = command name
	check_ACK(str_ack,cmdname.c_str(),timeout_secs, timeout_nanosecs);
	Tango::DevString argout = CORBA::string_dup(str_ack.c_str());
	return argout;
}
//+------------------------------------------------------------------
/**
 *	method:	MKS_MicrovisionIP_RGA::start
 *
 *	description:	This is an internal method to create all
 *			necessary attributes for this device.
 *			The method is only executed once after the
 *			creation of the device.
 */
//+------------------------------------------------------------------
void MKS_MicrovisionIP_RGA::start()
{
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::start(): entering... !" << endl;

	//
	// loop over the list of attributes to be created!
	for (int i = 1; i <= MaxMass ; i++)
	{
		Tango::Attr *mass;
		char attrname[10];
		char strtmp[10];
		sprintf(attrname,"Mass%d",i);
		double t2 = get_ticks();
		try
		{
			// the attribute will be externally triggered
			// (the server will fill the polling buffer and not Tango)
			init_attr_poll_ext_trig(attrname); 
		}
		catch(Tango::DevFailed &e)
		{
			Tango::Except::print_exception(e);
		}
		double t3 = get_ticks();
		cout << "init_attr_poll_ext_trig(" << attrname << ") => " << t3-t2 << " ms" << endl;
	}
	
	DEBUG_STREAM << "MKS_MicrovisionIP_RGA::start(): exiting... !" << endl;
	return;	
}
double MKS_MicrovisionIP_RGA::get_ticks() {

#ifdef WIN32

  return (double)GetTickCount();

#else

  struct timeval tv;
  gettimeofday(&tv,NULL);
  return ( (tv.tv_sec)*1000.0 + (double)tv.tv_usec/1000.0 );

#endif

}


/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGA::namespace_ending
} //	namespace

/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGAClass.cpp) ENABLED START -----*/
static const char *RcsId      = "$Id:  $";
static const char *TagName    = "$Name:  $";
static const char *CvsPath    = "$Source:  $";
static const char *SvnPath    = "$HeadURL:  $";
static const char *HttpServer = "http://www.esrf.eu/computing/cs/tango/tango_doc/ds_doc/";
//=============================================================================
//
// file :        MKS_MicrovisionIP_RGAClass.cpp
//
// description : C++ source for the MKS_MicrovisionIP_RGAClass.
//               A singleton class derived from DeviceClass.
//               It implements the command and attribute list
//               and all properties and methods required
//               by the MKS_MicrovisionIP_RGA once per process.
//
// project :     MKS Microvision IP RGA
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <tango.h>
#include <MKS_MicrovisionIP_RGA.h>
#include <MKS_MicrovisionIP_RGAClass.h>

/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGAClass.cpp

//-------------------------------------------------------------------
/**
 *	Create MKS_MicrovisionIP_RGAClass singleton and
 *	return it in a C function for Python usage
 */
//-------------------------------------------------------------------
extern "C" {
#ifdef _TG_WINDOWS_

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_MKS_MicrovisionIP_RGA_class(const char *name) {
		return MKS_MicrovisionIP_RGA_ns::MKS_MicrovisionIP_RGAClass::init(name);
	}
}

namespace MKS_MicrovisionIP_RGA_ns
{
//===================================================================
//	Initialize pointer for singleton pattern
//===================================================================
MKS_MicrovisionIP_RGAClass *MKS_MicrovisionIP_RGAClass::_instance = NULL;

//--------------------------------------------------------
/**
 * method : 		MKS_MicrovisionIP_RGAClass::MKS_MicrovisionIP_RGAClass(string &s)
 * description : 	constructor for the MKS_MicrovisionIP_RGAClass
 *
 * @param s	The class name
 */
//--------------------------------------------------------
MKS_MicrovisionIP_RGAClass::MKS_MicrovisionIP_RGAClass(string &s):Tango::DeviceClass(s)
{
	cout2 << "Entering MKS_MicrovisionIP_RGAClass constructor" << endl;
	set_default_property();
	write_class_property();

	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGAClass::constructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGAClass::constructor

	cout2 << "Leaving MKS_MicrovisionIP_RGAClass constructor" << endl;
}

//--------------------------------------------------------
/**
 * method : 		MKS_MicrovisionIP_RGAClass::~MKS_MicrovisionIP_RGAClass()
 * description : 	destructor for the MKS_MicrovisionIP_RGAClass
 */
//--------------------------------------------------------
MKS_MicrovisionIP_RGAClass::~MKS_MicrovisionIP_RGAClass()
{
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGAClass::destructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGAClass::destructor

	_instance = NULL;
}


//--------------------------------------------------------
/**
 * method : 		MKS_MicrovisionIP_RGAClass::init
 * description : 	Create the object if not already done.
 *                  Otherwise, just return a pointer to the object
 *
 * @param	name	The class name
 */
//--------------------------------------------------------
MKS_MicrovisionIP_RGAClass *MKS_MicrovisionIP_RGAClass::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new MKS_MicrovisionIP_RGAClass(s);
		}
		catch (bad_alloc &)
		{
			throw;
		}
	}
	return _instance;
}

//--------------------------------------------------------
/**
 * method : 		MKS_MicrovisionIP_RGAClass::instance
 * description : 	Check if object already created,
 *                  and return a pointer to the object
 */
//--------------------------------------------------------
MKS_MicrovisionIP_RGAClass *MKS_MicrovisionIP_RGAClass::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}



//===================================================================
//	Command execution method calls
//===================================================================
//--------------------------------------------------------
/**
 * method : 		OnClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *OnClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "OnClass::execute(): arrived" << endl;
	((static_cast<MKS_MicrovisionIP_RGA *>(device))->on());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		OffClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *OffClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "OffClass::execute(): arrived" << endl;
	((static_cast<MKS_MicrovisionIP_RGA *>(device))->off());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ResetClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ResetClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ResetClass::execute(): arrived" << endl;
	((static_cast<MKS_MicrovisionIP_RGA *>(device))->reset());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SendCmdClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SendCmdClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "SendCmdClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	return insert((static_cast<MKS_MicrovisionIP_RGA *>(device))->send_cmd(argin));
}

//--------------------------------------------------------
/**
 * method : 		ReleaseClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ReleaseClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ReleaseClass::execute(): arrived" << endl;
	((static_cast<MKS_MicrovisionIP_RGA *>(device))->release());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		StartDegasClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *StartDegasClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "StartDegasClass::execute(): arrived" << endl;
	((static_cast<MKS_MicrovisionIP_RGA *>(device))->start_degas());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		StopDegasClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *StopDegasClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "StopDegasClass::execute(): arrived" << endl;
	((static_cast<MKS_MicrovisionIP_RGA *>(device))->stop_degas());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		StoreStaticPressClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *StoreStaticPressClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "StoreStaticPressClass::execute(): arrived" << endl;
	((static_cast<MKS_MicrovisionIP_RGA *>(device))->store_static_press());
	return new CORBA::Any();
}


//===================================================================
//	Properties management
//===================================================================
//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGAClass::get_class_property()
 *	Description : Get the class property for specified name.
 */
//--------------------------------------------------------
Tango::DbDatum MKS_MicrovisionIP_RGAClass::get_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, returns  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGAClass::get_default_device_property()
 *	Description : Return the default value for device property.
 */
//--------------------------------------------------------
Tango::DbDatum MKS_MicrovisionIP_RGAClass::get_default_device_property(string &prop_name)
{
	for (unsigned int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGAClass::get_default_class_property()
 *	Description : Return the default value for class property.
 */
//--------------------------------------------------------
Tango::DbDatum MKS_MicrovisionIP_RGAClass::get_default_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}


//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGAClass::set_default_property()
 *	Description : Set default property (class and device) for wizard.
 *                For each property, add to wizard property name and description.
 *                If default value has been set, add it to wizard property and
 *                store it in a DbDatum.
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGAClass::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;
	vector<string>	vect_data;

	//	Set Default Class Properties

	//	Set Default device Properties
	prop_name = "Socket_device";
	prop_desc = "Name of the Socket device.";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Timeout";
	prop_desc = "Maximum time in ms to wait before getting the response of a command.";
	prop_def  = "2000";
	vect_data.clear();
	vect_data.push_back("2000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Accuracy";
	prop_desc = "Scanning accuracy at startup.";
	prop_def  = "5";
	vect_data.clear();
	vect_data.push_back("5");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "FilamentNumber";
	prop_desc = "Filament number at startup.";
	prop_def  = "1";
	vect_data.clear();
	vect_data.push_back("1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DetectorIndex";
	prop_desc = "Detector Index at startup.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "StartMass";
	prop_desc = "Start Mass used at startup for barchart and analog measurement modes.";
	prop_def  = "1";
	vect_data.clear();
	vect_data.push_back("1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EndMass";
	prop_desc = "EndMass used at startup in barchart and analog measurement modes.";
	prop_def  = "100";
	vect_data.clear();
	vect_data.push_back("100");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "LeakCheckMass";
	prop_desc = "Mass scanned in Single Peak measurement mode (LeakCheck mode).";
	prop_def  = "28";
	vect_data.clear();
	vect_data.push_back("28");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Gain";
	prop_desc = "Electronic gain Index used at startup.";
	prop_def  = "2";
	vect_data.clear();
	vect_data.push_back("2");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "MeasurementMode";
	prop_desc = "Measurement Mode used at startup.\nPossible values are :\n- LeakCheck (SinglePeak)\n- Barchart\n- Analog";
	prop_def  = "Barchart";
	vect_data.clear();
	vect_data.push_back("Barchart");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Time_until_reinit";
	prop_desc = "Time to wait (in seconds) before reinitialization of the server when no more\ndata come from the RGA and release command was not used.";
	prop_def  = "60";
	vect_data.clear();
	vect_data.push_back("60");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "SourceIndex";
	prop_desc = "Index of the source settings to use for measurement.\nThe MicroVision IP supports up to 6 sets of ion source\nparameters which can be configured to suit the hardware\nconfiguration and environment where the sensor is used.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "FilterMode";
	prop_desc = "Specifies how each AMU should be scanned and turned into a single reading:\n- PeakCenter:    Single point at the nominal peak center is measured\n- PeakMax:       Central 1/2 AMU scanned and the max value reported\n- PeakAverage: Central 1/2 AMIU scanned and the average value reported";
	prop_def  = "PeakCenter";
	vect_data.clear();
	vect_data.push_back("PeakCenter");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Min_detectable_pressure";
	prop_desc = "Minimum detectable pressure.\nIf the pressure measured is under that value,\nthe server will return a pressure equal to this min_detectable_pressure value.";
	prop_def  = "1e-12";
	vect_data.clear();
	vect_data.push_back("1e-12");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Degas_start_power";
	prop_desc = "Percentage power to start at when degassing";
	prop_def  = "10";
	vect_data.clear();
	vect_data.push_back("10");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Degas_end_power";
	prop_desc = "Percentage power to ramp to when degassing";
	prop_def  = "85";
	vect_data.clear();
	vect_data.push_back("85");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Degas_ramp_period";
	prop_desc = "Time in seconds to ramp between degas_start_power and degas_end_power when degassing";
	prop_def  = "90";
	vect_data.clear();
	vect_data.push_back("90");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Degas_max_power_period";
	prop_desc = "Time to hold at EndPower when degassing";
	prop_def  = "240";
	vect_data.clear();
	vect_data.push_back("240");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Degas_resettle_period";
	prop_desc = "Time to return to default settings";
	prop_def  = "30";
	vect_data.clear();
	vect_data.push_back("30");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "StaticPressures";
	prop_desc = "";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
}

//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGAClass::write_class_property()
 *	Description : Set class description fields as property in database
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGAClass::write_class_property()
{
	//	First time, check if database used
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("MKS Microvision IP RGA");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("This device server will control MKS Microvision IP Residual Gas Analyser.");
	description << str_desc;
	data.push_back(description);

	//  Put inheritance
	Tango::DbDatum	inher_datum("InheritedFrom");
	vector<string> inheritance;
	inheritance.push_back("TANGO_BASE_CLASS");
	inher_datum << inheritance;
	data.push_back(inher_datum);

	//	Call database and and values
	get_db_class()->put_property(data);
}

//===================================================================
//	Factory methods
//===================================================================

//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGAClass::device_factory()
 *	Description : Create the device object(s)
 *                and store them in the device list
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGAClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGAClass::device_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGAClass::device_factory_before

	//	Create devices and add it into the device list
	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
		device_list.push_back(new MKS_MicrovisionIP_RGA(this, (*devlist_ptr)[i]));
	}

	//	Manage dynamic attributes if any
	erase_dynamic_attributes(devlist_ptr, get_class_attr()->get_attr_list());

	//	Export devices to the outside world
	for (unsigned long i=1 ; i<=devlist_ptr->length() ; i++)
	{
		//	Add dynamic attributes if any
		MKS_MicrovisionIP_RGA *dev = static_cast<MKS_MicrovisionIP_RGA *>(device_list[device_list.size()-i]);
		dev->add_dynamic_attributes();

		//	Check before if database used.
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(dev);
		else
			export_device(dev, dev->get_name().c_str());
	}

	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGAClass::device_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGAClass::device_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGAClass::attribute_factory()
 *	Description : Create the attribute object(s)
 *                and store them in the attribute list
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGAClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGAClass::attribute_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGAClass::attribute_factory_before
	//	Attribute : MeasurementMode
	MeasurementModeAttrib	*measurementmode = new MeasurementModeAttrib();
	Tango::UserDefaultAttrProp	measurementmode_prop;
	measurementmode_prop.set_description("Possible values :\n- Barchart\n- LeakCheck\n- Analog");
	measurementmode_prop.set_label("Measurement Mode");
	//	unit	not set for MeasurementMode
	//	standard_unit	not set for MeasurementMode
	//	display_unit	not set for MeasurementMode
	//	format	not set for MeasurementMode
	//	max_value	not set for MeasurementMode
	//	min_value	not set for MeasurementMode
	//	max_alarm	not set for MeasurementMode
	//	min_alarm	not set for MeasurementMode
	//	max_warning	not set for MeasurementMode
	//	min_warning	not set for MeasurementMode
	//	delta_t	not set for MeasurementMode
	//	delta_val	not set for MeasurementMode
	
	measurementmode->set_default_properties(measurementmode_prop);
	//	Not Polled
	measurementmode->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(measurementmode);

	//	Attribute : Accuracy
	AccuracyAttrib	*accuracy = new AccuracyAttrib();
	Tango::UserDefaultAttrProp	accuracy_prop;
	accuracy_prop.set_description("Measurement accuracy\npossible values : 0 to 8 (best accuracy, minimum speed).");
	accuracy_prop.set_label("Accuracy");
	accuracy_prop.set_unit(" ");
	//	standard_unit	not set for Accuracy
	accuracy_prop.set_display_unit(" ");
	accuracy_prop.set_format("%1d");
	//	max_value	not set for Accuracy
	//	min_value	not set for Accuracy
	//	max_alarm	not set for Accuracy
	//	min_alarm	not set for Accuracy
	//	max_warning	not set for Accuracy
	//	min_warning	not set for Accuracy
	//	delta_t	not set for Accuracy
	//	delta_val	not set for Accuracy
	
	accuracy->set_default_properties(accuracy_prop);
	//	Not Polled
	accuracy->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(accuracy);

	//	Attribute : FilamentNumber
	FilamentNumberAttrib	*filamentnumber = new FilamentNumberAttrib();
	Tango::UserDefaultAttrProp	filamentnumber_prop;
	filamentnumber_prop.set_description("Number of the active filament.");
	filamentnumber_prop.set_label("Filament Number");
	filamentnumber_prop.set_unit(" ");
	//	standard_unit	not set for FilamentNumber
	filamentnumber_prop.set_display_unit(" ");
	filamentnumber_prop.set_format("%1d");
	//	max_value	not set for FilamentNumber
	//	min_value	not set for FilamentNumber
	//	max_alarm	not set for FilamentNumber
	//	min_alarm	not set for FilamentNumber
	//	max_warning	not set for FilamentNumber
	//	min_warning	not set for FilamentNumber
	//	delta_t	not set for FilamentNumber
	//	delta_val	not set for FilamentNumber
	
	filamentnumber->set_default_properties(filamentnumber_prop);
	//	Not Polled
	filamentnumber->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(filamentnumber);

	//	Attribute : DetectorIndex
	DetectorIndexAttrib	*detectorindex = new DetectorIndexAttrib();
	Tango::UserDefaultAttrProp	detectorindex_prop;
	detectorindex_prop.set_description("Detector (Multiplier) Index.\npossible values : from 0 to 3.\nChanges the selected measurements detector index. Faraday is detector 0 and if the sensor has a multiplier then\nindexes 1,2 and 3 provide alternate settings for the multiplier voltage.");
	detectorindex_prop.set_label("Detector Index");
	detectorindex_prop.set_unit(" ");
	//	standard_unit	not set for DetectorIndex
	detectorindex_prop.set_display_unit(" ");
	detectorindex_prop.set_format("%1d");
	//	max_value	not set for DetectorIndex
	//	min_value	not set for DetectorIndex
	//	max_alarm	not set for DetectorIndex
	//	min_alarm	not set for DetectorIndex
	//	max_warning	not set for DetectorIndex
	//	min_warning	not set for DetectorIndex
	//	delta_t	not set for DetectorIndex
	//	delta_val	not set for DetectorIndex
	
	detectorindex->set_default_properties(detectorindex_prop);
	//	Not Polled
	detectorindex->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(detectorindex);

	//	Attribute : DetectorVoltage
	DetectorVoltageAttrib	*detectorvoltage = new DetectorVoltageAttrib();
	Tango::UserDefaultAttrProp	detectorvoltage_prop;
	detectorvoltage_prop.set_description("Detector Voltage.");
	detectorvoltage_prop.set_label("Detector Voltage");
	detectorvoltage_prop.set_unit("V");
	//	standard_unit	not set for DetectorVoltage
	//	display_unit	not set for DetectorVoltage
	//	format	not set for DetectorVoltage
	//	max_value	not set for DetectorVoltage
	//	min_value	not set for DetectorVoltage
	//	max_alarm	not set for DetectorVoltage
	//	min_alarm	not set for DetectorVoltage
	//	max_warning	not set for DetectorVoltage
	//	min_warning	not set for DetectorVoltage
	//	delta_t	not set for DetectorVoltage
	//	delta_val	not set for DetectorVoltage
	
	detectorvoltage->set_default_properties(detectorvoltage_prop);
	//	Not Polled
	detectorvoltage->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(detectorvoltage);

	//	Attribute : StartMass
	StartMassAttrib	*startmass = new StartMassAttrib();
	Tango::UserDefaultAttrProp	startmass_prop;
	startmass_prop.set_description("Start Mass for Barchart scans.");
	startmass_prop.set_label("Start Mass");
	startmass_prop.set_unit(" ");
	//	standard_unit	not set for StartMass
	startmass_prop.set_display_unit(" ");
	startmass_prop.set_format("%3d");
	startmass_prop.set_max_value("100");
	startmass_prop.set_min_value("1");
	//	max_alarm	not set for StartMass
	//	min_alarm	not set for StartMass
	//	max_warning	not set for StartMass
	//	min_warning	not set for StartMass
	//	delta_t	not set for StartMass
	//	delta_val	not set for StartMass
	
	startmass->set_default_properties(startmass_prop);
	//	Not Polled
	startmass->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(startmass);

	//	Attribute : EndMass
	EndMassAttrib	*endmass = new EndMassAttrib();
	Tango::UserDefaultAttrProp	endmass_prop;
	endmass_prop.set_description("End Mass for Barchart scans.");
	endmass_prop.set_label("End Mass");
	endmass_prop.set_unit(" ");
	//	standard_unit	not set for EndMass
	endmass_prop.set_display_unit(" ");
	endmass_prop.set_format("%3d");
	endmass_prop.set_max_value("100");
	endmass_prop.set_min_value("1");
	//	max_alarm	not set for EndMass
	//	min_alarm	not set for EndMass
	//	max_warning	not set for EndMass
	//	min_warning	not set for EndMass
	//	delta_t	not set for EndMass
	//	delta_val	not set for EndMass
	
	endmass->set_default_properties(endmass_prop);
	//	Not Polled
	endmass->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(endmass);

	//	Attribute : LeakCheckMass
	LeakCheckMassAttrib	*leakcheckmass = new LeakCheckMassAttrib();
	Tango::UserDefaultAttrProp	leakcheckmass_prop;
	leakcheckmass_prop.set_description("Mass scanned in Leakcheck mode.\n(SinglePeak scans).");
	leakcheckmass_prop.set_label("LeakCheck Mass");
	leakcheckmass_prop.set_unit(" ");
	//	standard_unit	not set for LeakCheckMass
	leakcheckmass_prop.set_display_unit(" ");
	leakcheckmass_prop.set_format("%5.2f");
	leakcheckmass_prop.set_max_value("100");
	leakcheckmass_prop.set_min_value("1");
	//	max_alarm	not set for LeakCheckMass
	//	min_alarm	not set for LeakCheckMass
	//	max_warning	not set for LeakCheckMass
	//	min_warning	not set for LeakCheckMass
	//	delta_t	not set for LeakCheckMass
	//	delta_val	not set for LeakCheckMass
	
	leakcheckmass->set_default_properties(leakcheckmass_prop);
	//	Not Polled
	leakcheckmass->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(leakcheckmass);

	//	Attribute : Timeout
	TimeoutAttrib	*timeout = new TimeoutAttrib();
	Tango::UserDefaultAttrProp	timeout_prop;
	timeout_prop.set_description("Maximum time in ms to wait before getting the response of a command.");
	timeout_prop.set_label("Timeout");
	timeout_prop.set_unit("ms");
	timeout_prop.set_standard_unit("ms");
	timeout_prop.set_display_unit("ms");
	timeout_prop.set_format("%5d");
	//	max_value	not set for Timeout
	timeout_prop.set_min_value("1");
	//	max_alarm	not set for Timeout
	//	min_alarm	not set for Timeout
	//	max_warning	not set for Timeout
	//	min_warning	not set for Timeout
	//	delta_t	not set for Timeout
	//	delta_val	not set for Timeout
	
	timeout->set_default_properties(timeout_prop);
	//	Not Polled
	timeout->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(timeout);

	//	Attribute : Gain
	GainAttrib	*gain = new GainAttrib();
	Tango::UserDefaultAttrProp	gain_prop;
	gain_prop.set_description("Electronic gain Index to use for the measurements.");
	gain_prop.set_label("Gain");
	gain_prop.set_unit(" ");
	//	standard_unit	not set for Gain
	gain_prop.set_display_unit(" ");
	gain_prop.set_format("%1d");
	//	max_value	not set for Gain
	//	min_value	not set for Gain
	//	max_alarm	not set for Gain
	//	min_alarm	not set for Gain
	//	max_warning	not set for Gain
	//	min_warning	not set for Gain
	//	delta_t	not set for Gain
	//	delta_val	not set for Gain
	
	gain->set_default_properties(gain_prop);
	//	Not Polled
	gain->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(gain);

	//	Attribute : SourceIndex
	SourceIndexAttrib	*sourceindex = new SourceIndexAttrib();
	Tango::UserDefaultAttrProp	sourceindex_prop;
	sourceindex_prop.set_description("Index of the source settings to use for measurement.\nThe MicroVision IP supports up to 6 sets of ion source \nparameters which can be configured to suit the hardware \nconfiguration and environment where the sensor is used.");
	sourceindex_prop.set_label("Source");
	sourceindex_prop.set_unit(" ");
	//	standard_unit	not set for SourceIndex
	//	display_unit	not set for SourceIndex
	sourceindex_prop.set_format("%1d");
	//	max_value	not set for SourceIndex
	//	min_value	not set for SourceIndex
	//	max_alarm	not set for SourceIndex
	//	min_alarm	not set for SourceIndex
	//	max_warning	not set for SourceIndex
	//	min_warning	not set for SourceIndex
	//	delta_t	not set for SourceIndex
	//	delta_val	not set for SourceIndex
	
	sourceindex->set_default_properties(sourceindex_prop);
	//	Not Polled
	sourceindex->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(sourceindex);

	//	Attribute : FilterMode
	FilterModeAttrib	*filtermode = new FilterModeAttrib();
	Tango::UserDefaultAttrProp	filtermode_prop;
	filtermode_prop.set_description("Specifies how each AMU should be scanned and turned into a single reading:\n- PeakCenter:    Single point at the nominal peak center is measured\n- PeakMax:       Central 1/2 AMU scanned and the max value reported\n- PeakAverage: Central 1/2 AMIU scanned and the average value reported");
	filtermode_prop.set_label("Filter Mode");
	filtermode_prop.set_unit(" ");
	//	standard_unit	not set for FilterMode
	//	display_unit	not set for FilterMode
	//	format	not set for FilterMode
	//	max_value	not set for FilterMode
	//	min_value	not set for FilterMode
	//	max_alarm	not set for FilterMode
	//	min_alarm	not set for FilterMode
	//	max_warning	not set for FilterMode
	//	min_warning	not set for FilterMode
	//	delta_t	not set for FilterMode
	//	delta_val	not set for FilterMode
	
	filtermode->set_default_properties(filtermode_prop);
	//	Not Polled
	filtermode->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(filtermode);

	//	Attribute : LeakCheckPressure
	LeakCheckPressureAttrib	*leakcheckpressure = new LeakCheckPressureAttrib();
	Tango::UserDefaultAttrProp	leakcheckpressure_prop;
	leakcheckpressure_prop.set_description("This is the pressure of the mass defined by the LeakCheckMass attribute.");
	leakcheckpressure_prop.set_label("Leakcheck Pressure");
	leakcheckpressure_prop.set_unit("mBar");
	//	standard_unit	not set for LeakCheckPressure
	//	display_unit	not set for LeakCheckPressure
	leakcheckpressure_prop.set_format("%.3e");
	//	max_value	not set for LeakCheckPressure
	//	min_value	not set for LeakCheckPressure
	//	max_alarm	not set for LeakCheckPressure
	//	min_alarm	not set for LeakCheckPressure
	//	max_warning	not set for LeakCheckPressure
	//	min_warning	not set for LeakCheckPressure
	//	delta_t	not set for LeakCheckPressure
	//	delta_val	not set for LeakCheckPressure
	
	leakcheckpressure->set_default_properties(leakcheckpressure_prop);
	//	Not Polled
	leakcheckpressure->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	leakcheckpressure->set_change_event(true, false);
	att_list.push_back(leakcheckpressure);

	//	Attribute : DegasStatus
	DegasStatusAttrib	*degasstatus = new DegasStatusAttrib();
	Tango::UserDefaultAttrProp	degasstatus_prop;
	degasstatus_prop.set_description("Status of the degassing process");
	degasstatus_prop.set_label("Degas Status");
	//	unit	not set for DegasStatus
	//	standard_unit	not set for DegasStatus
	//	display_unit	not set for DegasStatus
	//	format	not set for DegasStatus
	//	max_value	not set for DegasStatus
	//	min_value	not set for DegasStatus
	//	max_alarm	not set for DegasStatus
	//	min_alarm	not set for DegasStatus
	//	max_warning	not set for DegasStatus
	//	min_warning	not set for DegasStatus
	//	delta_t	not set for DegasStatus
	//	delta_val	not set for DegasStatus
	
	degasstatus->set_default_properties(degasstatus_prop);
	//	Not Polled
	degasstatus->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(degasstatus);

	//	Attribute : FilamentDegas
	FilamentDegasAttrib	*filamentdegas = new FilamentDegasAttrib();
	Tango::UserDefaultAttrProp	filamentdegas_prop;
	filamentdegas_prop.set_description("When this attribute is set to true, it will start the degassing process on the \ncurrent selected filament.\nThe attribute will stay true until the filament degassing process will end.\nWhen this attribute is set to false, it will call the StopDegas command.");
	filamentdegas_prop.set_label("Filament Degas");
	//	unit	not set for FilamentDegas
	//	standard_unit	not set for FilamentDegas
	//	display_unit	not set for FilamentDegas
	//	format	not set for FilamentDegas
	//	max_value	not set for FilamentDegas
	//	min_value	not set for FilamentDegas
	//	max_alarm	not set for FilamentDegas
	//	min_alarm	not set for FilamentDegas
	//	max_warning	not set for FilamentDegas
	//	min_warning	not set for FilamentDegas
	//	delta_t	not set for FilamentDegas
	//	delta_val	not set for FilamentDegas
	
	filamentdegas->set_default_properties(filamentdegas_prop);
	//	Not Polled
	filamentdegas->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(filamentdegas);

	//	Attribute : LifetimePressure
	LifetimePressureAttrib	*lifetimepressure = new LifetimePressureAttrib();
	Tango::UserDefaultAttrProp	lifetimepressure_prop;
	lifetimepressure_prop.set_description("Apparent pressure contributing to the lifetime.\nThis is the weighted sum of partial pressures * Z^2");
	//	label	not set for LifetimePressure
	lifetimepressure_prop.set_unit("mB");
	//	standard_unit	not set for LifetimePressure
	//	display_unit	not set for LifetimePressure
	//	format	not set for LifetimePressure
	//	max_value	not set for LifetimePressure
	//	min_value	not set for LifetimePressure
	//	max_alarm	not set for LifetimePressure
	//	min_alarm	not set for LifetimePressure
	//	max_warning	not set for LifetimePressure
	//	min_warning	not set for LifetimePressure
	//	delta_t	not set for LifetimePressure
	//	delta_val	not set for LifetimePressure
	
	lifetimepressure->set_default_properties(lifetimepressure_prop);
	//	Not Polled
	lifetimepressure->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(lifetimepressure);

	//	Attribute : Masses
	MassesAttrib	*masses = new MassesAttrib();
	Tango::UserDefaultAttrProp	masses_prop;
	//	description	not set for Masses
	masses_prop.set_label("Masses");
	masses_prop.set_unit(" ");
	masses_prop.set_standard_unit("mBar");
	masses_prop.set_display_unit(" ");
	masses_prop.set_format("%.3e");
	//	max_value	not set for Masses
	//	min_value	not set for Masses
	//	max_alarm	not set for Masses
	//	min_alarm	not set for Masses
	//	max_warning	not set for Masses
	//	min_warning	not set for Masses
	//	delta_t	not set for Masses
	//	delta_val	not set for Masses
	
	masses->set_default_properties(masses_prop);
	//	Not Polled
	masses->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(masses);

	//	Attribute : MassesHistory
	MassesHistoryAttrib	*masseshistory = new MassesHistoryAttrib();
	Tango::UserDefaultAttrProp	masseshistory_prop;
	masseshistory_prop.set_description("This attribute is the same as the Masses attribute and was \ncreated to be able to have another polling period and a buffer history.");
	masseshistory_prop.set_label("Masses history");
	//	unit	not set for MassesHistory
	masseshistory_prop.set_standard_unit("mBar");
	//	display_unit	not set for MassesHistory
	masseshistory_prop.set_format("%.3e");
	//	max_value	not set for MassesHistory
	//	min_value	not set for MassesHistory
	//	max_alarm	not set for MassesHistory
	//	min_alarm	not set for MassesHistory
	//	max_warning	not set for MassesHistory
	//	min_warning	not set for MassesHistory
	//	delta_t	not set for MassesHistory
	//	delta_val	not set for MassesHistory
	
	masseshistory->set_default_properties(masseshistory_prop);
	masseshistory->set_polling_period(40000);
	masseshistory->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(masseshistory);

	//	Attribute : StaticPressures
	StaticPressuresAttrib	*staticpressures = new StaticPressuresAttrib();
	Tango::UserDefaultAttrProp	staticpressures_prop;
	staticpressures_prop.set_description("spectrum of pressure taken when beam is at 0.");
	//	label	not set for StaticPressures
	//	unit	not set for StaticPressures
	staticpressures_prop.set_standard_unit("mBar");
	staticpressures_prop.set_display_unit(" ");
	staticpressures_prop.set_format("%.3e");
	//	max_value	not set for StaticPressures
	//	min_value	not set for StaticPressures
	//	max_alarm	not set for StaticPressures
	//	min_alarm	not set for StaticPressures
	//	max_warning	not set for StaticPressures
	//	min_warning	not set for StaticPressures
	//	delta_t	not set for StaticPressures
	//	delta_val	not set for StaticPressures
	
	staticpressures->set_default_properties(staticpressures_prop);
	//	Not Polled
	staticpressures->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(staticpressures);


	//	Create a list of static attributes
	create_static_attribute_list(get_class_attr()->get_attr_list());
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGAClass::attribute_factory_after) ENABLED START -----*/
		
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGAClass::attribute_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGAClass::pipe_factory()
 *	Description : Create the pipe object(s)
 *                and store them in the pipe list
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGAClass::pipe_factory()
{
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGAClass::pipe_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGAClass::pipe_factory_before
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGAClass::pipe_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGAClass::pipe_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGAClass::command_factory()
 *	Description : Create the command object(s)
 *                and store them in the command list
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGAClass::command_factory()
{
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGAClass::command_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGAClass::command_factory_before


	//	Command On
	OnClass	*pOnCmd =
		new OnClass("On",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pOnCmd);

	//	Command Off
	OffClass	*pOffCmd =
		new OffClass("Off",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pOffCmd);

	//	Command Reset
	ResetClass	*pResetCmd =
		new ResetClass("Reset",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pResetCmd);

	//	Command SendCmd
	SendCmdClass	*pSendCmdCmd =
		new SendCmdClass("SendCmd",
			Tango::DEV_STRING, Tango::DEV_STRING,
			"Command to send to RGA",
			"Response from RGA",
			Tango::EXPERT);
	command_list.push_back(pSendCmdCmd);

	//	Command Release
	ReleaseClass	*pReleaseCmd =
		new ReleaseClass("Release",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::EXPERT);
	command_list.push_back(pReleaseCmd);

	//	Command StartDegas
	StartDegasClass	*pStartDegasCmd =
		new StartDegasClass("StartDegas",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::EXPERT);
	command_list.push_back(pStartDegasCmd);

	//	Command StopDegas
	StopDegasClass	*pStopDegasCmd =
		new StopDegasClass("StopDegas",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::EXPERT);
	command_list.push_back(pStopDegasCmd);

	//	Command StoreStaticPress
	StoreStaticPressClass	*pStoreStaticPressCmd =
		new StoreStaticPressClass("StoreStaticPress",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pStoreStaticPressCmd);

	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGAClass::command_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGAClass::command_factory_after
}

//===================================================================
//	Dynamic attributes related methods
//===================================================================

//--------------------------------------------------------
/**
 * method : 		MKS_MicrovisionIP_RGAClass::create_static_attribute_list
 * description : 	Create the a list of static attributes
 *
 * @param	att_list	the ceated attribute list
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGAClass::create_static_attribute_list(vector<Tango::Attr *> &att_list)
{
	for (unsigned long i=0 ; i<att_list.size() ; i++)
	{
		string att_name(att_list[i]->get_name());
		transform(att_name.begin(), att_name.end(), att_name.begin(), ::tolower);
		defaultAttList.push_back(att_name);
	}

	cout2 << defaultAttList.size() << " attributes in default list" << endl;

	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGAClass::create_static_att_list) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGAClass::create_static_att_list
}


//--------------------------------------------------------
/**
 * method : 		MKS_MicrovisionIP_RGAClass::erase_dynamic_attributes
 * description : 	delete the dynamic attributes if any.
 *
 * @param	devlist_ptr	the device list pointer
 * @param	list of all attributes
 */
//--------------------------------------------------------
void MKS_MicrovisionIP_RGAClass::erase_dynamic_attributes(const Tango::DevVarStringArray *devlist_ptr, vector<Tango::Attr *> &att_list)
{
	Tango::Util *tg = Tango::Util::instance();

	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		Tango::DeviceImpl *dev_impl = tg->get_device_by_name(((string)(*devlist_ptr)[i]).c_str());
		MKS_MicrovisionIP_RGA *dev = static_cast<MKS_MicrovisionIP_RGA *> (dev_impl);

		vector<Tango::Attribute *> &dev_att_list = dev->get_device_attr()->get_attribute_list();
		vector<Tango::Attribute *>::iterator ite_att;
		for (ite_att=dev_att_list.begin() ; ite_att != dev_att_list.end() ; ++ite_att)
		{
			string att_name((*ite_att)->get_name_lower());
			if ((att_name == "state") || (att_name == "status"))
				continue;
			vector<string>::iterator ite_str = find(defaultAttList.begin(), defaultAttList.end(), att_name);
			if (ite_str == defaultAttList.end())
			{
				cout2 << att_name << " is a UNWANTED dynamic attribute for device " << (*devlist_ptr)[i] << endl;
				Tango::Attribute &att = dev->get_device_attr()->get_attr_by_name(att_name.c_str());
				dev->remove_attribute(att_list[att.get_attr_idx()], true, false);
				--ite_att;
			}
		}
	}
	/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGAClass::erase_dynamic_attributes) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGAClass::erase_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Method      : MKS_MicrovisionIP_RGAClass::get_attr_object_by_name()
 *	Description : returns Tango::Attr * object found by name
 */
//--------------------------------------------------------
Tango::Attr *MKS_MicrovisionIP_RGAClass::get_attr_object_by_name(vector<Tango::Attr *> &att_list, string attname)
{
	vector<Tango::Attr *>::iterator it;
	for (it=att_list.begin() ; it<att_list.end() ; ++it)
		if ((*it)->get_name()==attname)
			return (*it);
	//	Attr does not exist
	return NULL;
}


/*----- PROTECTED REGION ID(MKS_MicrovisionIP_RGAClass::Additional Methods) ENABLED START -----*/

/*----- PROTECTED REGION END -----*/	//	MKS_MicrovisionIP_RGAClass::Additional Methods
} //	namespace

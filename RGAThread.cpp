static const char *RcsId     = "$Header: /users/chaize/newsvn/cvsroot/Vacuum/MKS_MicrovisionIP_RGA/src/RGAThread.cpp,v 1.15 2008-10-25 18:10:27 jmchaize Exp $";
//=============================================================================
//
// file :        RGAThread.cpp
//
// description : Thread c++ source code for MKS_MicrovisionIP_RGA device server
//
// project :	MKS Microvision IP RGA
//
// $Author: jmchaize $
//
// $Revision: 1.15 $
//
// $Log: not supported by cvs2svn $
// Revision 1.14  2007/07/03 11:57:06  bourtemb
// Do not send archive events when the filament is not ON.
//
// Revision 1.13  2007/06/13 07:10:46  bourtemb
// This version is able to detect the filaments trips.
// In this case, the device is in FAULT and the status shows the reason
// why the filament tripped.
//
// Revision 1.12  2006/11/16 14:35:26  bourtemb
// Add LeakCheckPressure attribute.
// Use the push_events features for this new attribute only when we are in
// LeakCheck mode.
// When the device is in leakcheck mode, the dynamic masses are not refreshed
// and therefore, no event is sent for the dynamic MassXX attributes in this mode.
//
// Revision 1.11  2006/08/22 08:35:43  bourtemb
// min_detectable_pressure is now a device property
//
// Revision 1.10  2006/07/05 14:26:54  bourtemb
// round(MassPosition) when receiving MassReading notification to handle different
// measurement filter modes (peakcenter, peakmax and peakaverage)
//
// Revision 1.9  2006/07/05 07:11:31  bourtemb
// convert mass readings from Pascal to mBar
//
// Revision 1.8  2006/05/31 15:02:04  bourtemb
// use omni_condition to signal the reception of the result of a command
//
// Revision 1.7  2006/05/23 15:33:38  bourtemb
// fill the Tango polling buffer when a mass is read
// fire change and archive event when a mass is read
// include math.h
// No DeviceProxy on the RGA device
// The server use join(NULL) to wait for the thread death now.
// ScanResume 32000 -> ScanResume 16000
// cout ScanResume command ifdef ASTELNET
// if scanresume OK => scanstarted=true
//
// Revision 1.6  2005/12/14 16:45:19  bourtemb
// Change some bad comments.
// refactoring of the code.
//
// Revision 1.5  2005/12/05 12:31:31  bourtemb
// RFTrip Fault is latched.
// Reset command resets only the faults.
// ScanRestart after changing Gain or DetectorIndex.
// LinkDown message is now treated, add a message in the status in case of linkdown.
// Change DetectorVoltage setpoint and readpoint when changing DetectorIndex.
//
// Revision 1.4  2005/11/30 16:08:05  bourtemb
// initialize isconnected variable
//
// Revision 1.3  2005/11/29 12:28:29  bourtemb
// Create the attributes Mass# dynamically with their default properties.
//
// Revision 1.2  2005/11/28 15:21:41  bourtemb
// Report RFTripped Fault in dev_state and dev_status
// Last check in before to adapt the code to create dynamic attributes for the masses.
//
// Revision 1.1.1.1  2005/11/28 12:15:08  bourtemb
// Imported using TkCVS
//
//
// copyleft :    European Synchrotron Radiation Facility
//               BP 220, Grenoble 38043
//               FRANCE
//
//=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================
#include <RGAThread.h>
#include <sys/time.h>
#include <math.h>

namespace MKS_MicrovisionIP_RGA_ns
{

RGAThread::RGAThread (MKS_MicrovisionIP_RGA *obj, omni_mutex &m) : 
			omni_thread(),mutex(m),Tango::LogAdapter((Tango::DeviceImpl *)obj)
{
	DEBUG_STREAM << ">>>> RGAThread::RGAThread(): entering ....!" << endl;
	rga_obj = obj;
	socketdsOK = false;
	attr_list = NULL;
	tg= NULL;
	start_undetached();
}

// method : RGAThread::clean_exit()
// This method is called when the thread must be killed
// It will free all the necessary resources
// and commit suicide
void RGAThread::clean_exit()
{
	DEBUG_STREAM << ">>>> The thread must be killed! Exiting ..." << endl;
	// Free resources 
	if(socketdsOK)
		delete socketds;
	DEBUG_STREAM << ">>>> Thread DEATH ..." << endl;
	exit();
}


//
// RGAThread::run_undetached 
//
void *RGAThread::run_undetached (void *arg)
{
	DEBUG_STREAM << ">>>> RGAThread starting up!" << endl;
	{
		omni_mutex_lock * l = new omni_mutex_lock(mutex);
		min_detectable_pressure = rga_obj->min_detectable_pressure;
		try
		{
			socketds = new Tango::DeviceProxy(rga_obj->socket_device);
			socketdsOK = true;
			isconnected = true;
		}
		catch(Tango::DevFailed &e)
		{
			rga_obj->threadisconnected = false;
			Tango::Except::print_exception(e);
			delete l;
			clean_exit();
		}
		delete l;
	}
	
	while(true)
	{
		DEBUG_STREAM << ">>>> Begining of While loop" <<endl;
		// We want to stop ??
		{
			omni_mutex_lock *l = new omni_mutex_lock (mutex);
				
			if ( rga_obj->killthread == true)
			{
				delete l;
				clean_exit();
			}
			delete l;
		}
		// try to read one answer :
		try
		{
			string cmd_delim = "\r\r";
			Tango::DeviceData argin;
			argin << cmd_delim;
			string answer = "";
#ifdef TIMEPERF
			double before = get_ticks();
#endif
			Tango::DeviceData data_ans = socketds->command_inout("ReadUntil",argin);
#ifdef TIMEPERF
			double after = get_ticks();
			cout << "Server time for ReadUntil = " <<  after - before << " ms" << endl;
#endif
			data_ans >> answer;
			parse_answer(answer);
			if(!isconnected)
			{
				omni_mutex_lock l(mutex);
				rga_obj->threadisconnected = true;
				isconnected = true;
			}
		}
		catch(Tango::DevFailed &e)
		{
			// Tango::Except::print_exception(e);
			if(isconnected)
			{
				{
					omni_mutex_lock l(mutex);
					rga_obj->threadisconnected = false;
				}
				isconnected = false;
			}
			usleep(20000);
		}
	} // while

	return NULL;
}

bool RGAThread::parse_answer(const string & resp)
{
	DEBUG_STREAM << "response to parse : " << resp << endl;
#ifdef ASTELNET
	cout << resp << endl;
#endif
	istringstream ans(resp);
	char line1[256];
	char c;	
	ans.getline(line1,256,'\r');
	DEBUG_STREAM << "line 1 = " << line1 << endl;
	istringstream issline1(line1);
	char cmd[256];
	issline1 >> cmd;
	DEBUG_STREAM << "Command Name = " << cmd << endl;
	
	static double previous_time = 0;
	static long prevscantime = 0;
		
	  ///////////////////////////////////////////////////
	 //                    MKSRGA                     //
	///////////////////////////////////////////////////
	if(strcmp(cmd,"MKSRGA") == 0)
	{
		char multi_single[10];
		issline1 >> multi_single;
		DEBUG_STREAM << "MULTI/SINGLE = " << multi_single << endl;
		ans.get(c);
		if(c == '\n')
		{
			DEBUG_STREAM << "<crlf>" << endl;
		}
		else
		{
			ERROR_STREAM << "Syntax error ?? \\r\\n expected." << endl;
			return false;
		}
		char line2[256];
		ans.getline(line2,256,'\r');
		DEBUG_STREAM << "line 2 = " << line2 << endl;
		istringstream issline2(line2);
		char Protocol_Revision[256];
		double ProtocolRev;
		issline2 >> Protocol_Revision;
		if (strcmp(Protocol_Revision,"Protocol_Revision") != 0)
			ERROR_STREAM << "Syntax error, Protocol_Revision expected." << endl;
		issline2 >> ProtocolRev;
			DEBUG_STREAM << "Protocol Revision = " << ProtocolRev << endl;
		ans.get(c);
		if(c == '\n')
		{
			DEBUG_STREAM << "<crlf>" << endl;
		}
		else
		{
			ERROR_STREAM << "Syntax error ?? \\r\\n expected." << endl;
			return false;
		}
		char line3[256];
		ans.getline(line3,256,'\r');
		DEBUG_STREAM << "line 3 = " << line3 << endl;
		istringstream issline3(line3);
		char Min_Compatibility[256];
		double Compatibility;
		issline3 >> Min_Compatibility;
		if (strcmp(Min_Compatibility,"Min_Compatibility") != 0)
			ERROR_STREAM << "Syntax error, Min_Compatibility expected." << endl;
		issline3 >> Compatibility;
			DEBUG_STREAM << "Min Compatibility = " << Compatibility << endl;
		ans.get(c);
		if(c == '\n')
		{
			DEBUG_STREAM << "<crlf>" << endl;
		}
		else
		{
			ERROR_STREAM << "Syntax error ?? \\r\\n expected." << endl;
			return false;
		}
		char line4[256];
		ans.getline(line4,256,'\r');
		DEBUG_STREAM << "strlen(line4) = " << strlen(line4) << endl;
		ans.get(c);
		if(c == '\n')
		{
			DEBUG_STREAM << "<crlf>" << endl;
		}
		else
		{
			ERROR_STREAM << "Syntax error ?? \\r\\n expected." << endl;
			return false;
		}
		char line5[256];
		ans.getline(line5,256,'\r');
		DEBUG_STREAM << "strlen(line5) = " << strlen(line5) << endl;
		ans.get(c);
		if(c == '\r')
		{
			DEBUG_STREAM << "<crcr>" << endl;
		}
		else
		{
			ERROR_STREAM << "Syntax error : \\r\\r expected at end of command" << endl;
			return false;
		}
		return true;
	}
	  ///////////////////////////////////////////////////
	 //           FilamentTimeRemaining               //
	///////////////////////////////////////////////////
	if(strcmp(cmd,"FilamentTimeRemaining") == 0)
	{
		long Time;
		issline1 >> Time;
		DEBUG_STREAM << "Filament Time Remaining = " << Time << endl;
		ans.get(c);
		if(c == '\n')
		{
			DEBUG_STREAM << "<crlf>" << endl;
		}
		else
		{
			ERROR_STREAM << "Syntax error ?? => " << c <<  endl;
			return false;
		}
		char line2[256];
		ans.getline(line2,256,'\r');
		DEBUG_STREAM << "strlen(line2) = " << strlen(line2) << endl;
		ans.get(c);
		if(c == '\r')
		{
			DEBUG_STREAM << "<crcr>" << endl;
		}
		else
		{
			ERROR_STREAM << "Syntax error : \\r\\r expected at end of command" << endl;
			return false;
		}
		return true;
	}
	  ///////////////////////////////////////////////////
	 //               FilamentStatus                  //
	///////////////////////////////////////////////////
	if(strcmp(cmd,"FilamentStatus") == 0)
	{
		string fstatus;
		string factive;
		issline1 >> factive;
		issline1 >> fstatus;
		DEBUG_STREAM << "FilamentStatus = Filament " << factive << " " << fstatus << endl;
		{
			omni_mutex_lock l(mutex);
			rga_obj->FilamentStatus = resp;
			rga_obj->ActiveFilament = factive;
			rga_obj->FilamentState = fstatus;
		}
		if((fstatus == "OFF") || (fstatus == "COOL-DOWN") || (fstatus == "BAD-EMISSION"))
		{
			ans.get(c);
			if(c == '\n')
			{
				DEBUG_STREAM << "<crlf>" << endl;
			}
			else
			{
				ERROR_STREAM << "Syntax error ?? => " << c <<  endl;
			}
			// Trip ?
			char line2[256];
			ans.getline(line2,256,'\r');
			DEBUG_STREAM << "line 2 = " << line2 << endl;
			istringstream issline2(line2);
			string trip;
			string trip_reason;
			issline2 >> trip;
			issline2 >> trip_reason;
			DEBUG_STREAM << "Trip Reason = " << trip_reason << endl;
			{
				omni_mutex_lock l(mutex);
				rga_obj->FilamentTripReason = trip_reason;
			}
		}
		
		
		//
		
		return true;
	}
	  ///////////////////////////////////////////////////
	 //                StartingScan                   //
	///////////////////////////////////////////////////
	if(strcmp(cmd,"StartingScan") == 0)
	{
		long scannumber;
		long time;
		long scanremaining;
		issline1 >> scannumber;
		issline1 >> time;
		issline1 >> scanremaining;
		DEBUG_STREAM << "StartingScan, scan number = " << scannumber << endl;
		DEBUG_STREAM << "StartingScan, time = " << time << " ms" << endl;
		DEBUG_STREAM << "StartingScan, scan remaining = " << scanremaining << endl;
#ifdef TIMEPERF
		cout << "RGA time for last scan = " << time - prevscantime << " ms" << endl;
		prevscantime = time;
		double now = get_ticks();
		cout << "Server time for last scan = " <<  now - previous_time << " ms" << endl;
		previous_time = now;
#endif
		if(scanremaining == 0)
		{
			string scanresumecmd = "ScanResume 16000";
			try
			{
				Tango::DeviceData in;
				in << scanresumecmd;
				DEBUG_STREAM << "RESTARTING SCAN " << endl;
				socketds->command_inout("Write",in);
#ifdef ASTELNET
				cout << scanresumecmd << endl;
#endif
			}
			catch(Tango::DevFailed &e) { 
			// Tango::Except::print_exception(e); 
			}
		}
		return true;
	}
	  ///////////////////////////////////////////////////
	 //            StartingMeasurement                //
	///////////////////////////////////////////////////
	if(strcmp(cmd,"StartingMeasurement") == 0)
	{
		string MeasurementName = "";
		issline1 >> MeasurementName;
		DEBUG_STREAM << "StartingMeasurement, measurement name = " << MeasurementName << endl;
		return true;
	}
	  ///////////////////////////////////////////////////
	 //                ZeroReading                    //
	///////////////////////////////////////////////////
	if(strcmp(cmd,"ZeroReading") == 0)
	{
		double MassPosition = 0;
		double value = 0;
		issline1 >> MassPosition;
		issline1 >> value;
		DEBUG_STREAM << "ZeroReading, Mass Position = " << MassPosition << endl;
		DEBUG_STREAM << "ZeroReading, value = " << value  << " Pa" << endl;
		return true;
	}
	  ///////////////////////////////////////////////////
	 //                MassReading                    //
	///////////////////////////////////////////////////
	if(strcmp(cmd,"MassReading") == 0)
	{
		if(tg == NULL)
			tg = Tango::Util::instance(false);
		double MassPosition = 0;
		Tango::DevDouble value = 0;
		issline1 >> MassPosition;
		issline1 >> value;
		DEBUG_STREAM << "MassReading, Mass Position = " << MassPosition << endl;
		DEBUG_STREAM << "MassReading, value = " << value << " Pa" << endl;
		// convert value from Pa to mbar
		value = value / 100.0;
		MassPosition = round(MassPosition);
		{
			omni_mutex_lock l(mutex);
			gettimeofday(&rga_obj->last_measure_time,NULL);
#ifndef NOLOWLIMIT
			if(value <= min_detectable_pressure)
				value = min_detectable_pressure;
#endif
			(rga_obj->Masses)[(unsigned int)MassPosition] = value;
			mode = rga_obj->mode;
		}
		/////////////////////// LEAKCHECK MODE //////////////////
		
		if(mode == LEAKCHECK)
		{
 			if(attr_list == NULL)
			{
 				try
				{
					attr_list = rga_obj->get_device_attr();
				}
				catch (Tango::DevFailed &e)
 				{
 					Tango::Except::print_exception(e);
					attr_list = NULL;
 				}
			}
			if(attr_list != NULL)
			{
				// We have to fire events for the LeakCheckPressure attribute
				Tango::Attribute &att_LeakCheckPressure = attr_list->get_attr_by_name ("LeakCheckPressure");
				try
				{
					// set the new values and fire the change event 
					omni_mutex_lock l(mutex);
					*(rga_obj->attr_LeakCheckPressure_read) = value;
					att_LeakCheckPressure.set_value(rga_obj->attr_LeakCheckPressure_read);
					att_LeakCheckPressure.fire_change_event ();
 				}
 				catch (Tango::DevFailed &e)
 				{
 					Tango::Except::print_exception(e);
 					att_LeakCheckPressure.fire_change_event (&e);
 				}
			}
			return true; // That's all we have to do if we are in LEAKCHECK mode
		}
		/////////////////////////////////////////////////////////
		Tango::AttrHistoryStack<Tango::DevDouble> chs;
		chs.length(1);
		TangoSys_OMemStream o;
		o << "Mass" << MassPosition;
		string attr_name = o.str();
		try
		{
			struct timeval when;
			gettimeofday(&when,NULL);
			Tango::TimedAttrData<Tango::DevDouble> tcd(&(rga_obj->Masses)[(unsigned int)MassPosition],when);
			chs.push(tcd);
			tg->fill_attr_polling_buffer(rga_obj,attr_name,chs);
		}
		catch(Tango::DevFailed &e)
		{
			ERROR_STREAM << "Error filling attr_polling_buffer for attribute " << attr_name << endl
			             << " is it correctly initialized as externally triggered?" << endl;
		}
		catch(...)
		{
			cout << " !!! Error fill_attr_polling_buffer !!!" << endl;
		}
 		try
 		{
 			if(attr_list == NULL)
 				attr_list = rga_obj->get_device_attr();
// 			
			
			else
			{
	 			Tango::Attribute &att_mass	      = attr_list->get_attr_by_name (attr_name.c_str());
	 			try
				{		 
 					// set the new values and fire the change event 
					omni_mutex_lock l(mutex);
					*((rga_obj->attr_Mass_read)[(unsigned int)MassPosition]) = value;
 					att_mass.set_value((rga_obj->attr_Mass_read)[(unsigned int)MassPosition]);
		 			att_mass.fire_change_event ();
 				}
 				catch (Tango::DevFailed &e)
 				{
 					Tango::Except::print_exception(e);
 					att_mass.fire_change_event (&e);
 				}
				if(rga_obj->FilamentState == "ON")
				{
					// Fire the archive event if and only if the Filament is ON
					try
					{		 
 						// set the new values and fire the archive event 
						omni_mutex_lock l(mutex);
						*((rga_obj->attr_Mass_read)[(unsigned int)MassPosition]) = value;
 						att_mass.set_value((rga_obj->attr_Mass_read)[(unsigned int)MassPosition]);
			 			att_mass.fire_archive_event ();
 					}
 					catch (Tango::DevFailed &e)
		 			{
		 				Tango::Except::print_exception(e);
 					}
				}
			}
 		}
 		catch(Tango::DevFailed &e)
 		{
 			Tango::Except::print_exception(e);
 		}	
		/////////////////////////////////////////////////////////
		return true;
	}
	  ///////////////////////////////////////////////////
	 //                 DegasReading                  //
	///////////////////////////////////////////////////
	if(strcmp(cmd,"DegasReading") == 0)
	{
		{
			omni_mutex_lock l(mutex);
			rga_obj->degas_status = resp;
		}
		string DegasReading;
		issline1 >> DegasReading;
		DEBUG_STREAM << "DegasReading = " << DegasReading << endl;
		if(DegasReading == "Complete")
		{
			omni_mutex_lock l(mutex);
			*(rga_obj->attr_FilamentDegas_read)=false;
		}
	}
	  ///////////////////////////////////////////////////
	 //               MultiplierStatus                //
	///////////////////////////////////////////////////
	if(strcmp(cmd,"MultiplierStatus") == 0)
	{
		string MultiplierStatus;
		issline1 >> MultiplierStatus;
		DEBUG_STREAM << "MultiplierStatus = " << MultiplierStatus << endl;
		{
			omni_mutex_lock l(mutex);
			rga_obj->MultiplierState = MultiplierStatus;		
		}
		return true;
	}
	  ///////////////////////////////////////////////////
	 //                  RFTripState                  //
	///////////////////////////////////////////////////
	if(strcmp(cmd,"RFTripState") == 0)
	{
		string RFTripState;
		issline1 >> RFTripState;
		if(strcasecmp(RFTripState.c_str(),"Tripped") == 0)
		{
			omni_mutex_lock l(mutex);
			rga_obj->RFTripped = true;
		}
		else
		{
			// OK
		}
		DEBUG_STREAM << "RFTripState " << RFTripState << endl;	
		return true;
	}
	  ///////////////////////////////////////////////////
	 //                  ScanResume                   //
	///////////////////////////////////////////////////
	if(strcmp(cmd,"ScanResume") == 0)
	{
		DEBUG_STREAM << "ScanResume" << endl;	
		string OK = "";
		issline1 >> OK;
		if(strcasecmp(OK.c_str(),"OK") == 0)
		{
			DEBUG_STREAM << "ScanResume OK" << endl;
			rga_obj->scanstarted = true;
		}
		else
		{
			ERROR_STREAM << resp << endl;
			// warn the server
			{
				omni_mutex_lock l(mutex);
				rga_obj->scanstarted = false;			
			}
		}
		return true;
	}
	  ///////////////////////////////////////////////////
	 //                  LinkDown                     //
	///////////////////////////////////////////////////
	if(strcmp(cmd,"LinkDown") == 0)
	{
		string Reason = "";
		issline1 >> Reason;
		DEBUG_STREAM << "LinkDown " << Reason << endl;
		if(strcasecmp(Reason.c_str(),"Serial") == 0)
		{
			omni_mutex_lock l(mutex);
			rga_obj->linkdown = LINK_DOWN_SERIAL;
		}
		else if(strcasecmp(Reason.c_str(),"VSC") == 0)
		{
			omni_mutex_lock l(mutex);
			rga_obj->linkdown = LINK_DOWN_VSC;
		}
		else
		{
			// New Protocol ???
		}
		return true;
	}
	
	// Todo : Add new asynchronous messages added in protocol >= 1.2
	  ///////////////////////////////////////////////////
	 //               Other Command                   //
	///////////////////////////////////////////////////	
	DEBUG_STREAM << "Other Command" << endl;
	{
		omni_mutex_lock l(mutex);
		rga_obj->RGA_Answer = resp;
		rga_obj->command_cond->broadcast();
	}
	return true;

}

double RGAThread::get_ticks() 
{
#ifdef WIN32
  return (double)GetTickCount();
#else
  struct timeval tv;
  gettimeofday(&tv,NULL);
  return ( (tv.tv_sec)*1000.0 + (double)tv.tv_usec/1000.0 );
#endif
}

} // namespace


